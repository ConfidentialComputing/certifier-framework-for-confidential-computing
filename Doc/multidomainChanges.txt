In August, 2023, we made changes to the Certifier API to support multi-domain programs.
This requires minor changes to some existing programs like the simple_app family of
programs.

Recall that every program has an identified (usually embedded) policy key that specifies
the security domain the program runs in.  There is a certifier service associated with
that security domain, namely the one that signs admissions certificates with that
policy key.

Now programs can certify not only in their primary domain (the one associated with the
embedded policy key) but in other domains with other policy keys.  As a result, the
principal object that carries out the Confidential Computing operations, has changed.

For existing programs that operate in a single security domain, like the simple_app
family of examples, the only changes are:

  1.  The call to cold_init in cc_trust_data has changed and takes more arguments.  It is now:

          bool cold_init(const string& public_key_alg, const string& symmetric_key_alg,
                     int asn1_cert_size, byte* asn1_cert,
                     const string& home_domain_name, const string& home_host,
                     int home_port, const string& service_host, int service_port);

          public_key_alg is the public key algorithm used, as before.
          symmetric_key_alg is the symmetric key algorithm, as before.
          asn1_cert is the der encoded self-signed policy key certificate and
            asn1_cert_size is its size.  Since the policy key cert is embedded in
            the program, these are predefined variable in most programs.
          home_domain_name is the name of the home (primary domain) which identifies
            the domain.  It can be any string as long as it is unique although it
            would be nice if it were descriptive.
          home_host is the ip address of the home domain's certifier service.
          home_port is the port number for the certifier service.
          service_host is the ip address of this applications server (in simple_app,
            this is the ip address of the ssl server exposed when the app runs as a server.
          service_port is the port number for the service.

      All these variables were used in the earlier simple_app but initialized in different
      places.  As always, the simple_app code completely illustrates its use.

  2. The call certify_me() now takes no arguments (They are set as a consequence of cold_init
     now.

Those are the only programmer visible changes for simple-app like applications.  None of the
deployment instructions or procedures change at all.

You can now get sertified in secondary domains with different policy keys too.  To do this,
first register the new domain by calling:

    bool add_new_domain(const string& domain_name, const string& cert, const string& host, int port,
          const string& service_host, int service_port);
    Here,
      domain_name is the secondary domain's domain name
      cert is the der encoded self-signed policy key certificate for the secondary domain.
      host is the ip address of the secondary domain's certifier service.
      port is the port number for the secondary domains certifier service.
      service_host and service_port have the same meaning as above.

Then call

  bool certify_secondary_domain(const string& domain_name);

to have the program certified in the secondary domain.  When you open a secure_authenticated_channel
to a secondary domain, you should use the self-signed policy cert and admissions_cert for the
targeted domain.  multi_domain_simple_example is a complete example of using these new calls.


These changes cause related changes in the key rotation examples.



Other changes

The policy store has been simplified and no longer contains the policy key.  If you use
the policy store currently only through cc_trust_app, you will notice no changes.  As well
as being simpler and more flexible, you can now have multiple policy stores for other
program data.  For example, you may wish to store your own authentication keys or symmetric
keys for services unrelated to a certifier_service in a seperate store.  This is now easy
to do.            

A few variable names have changed in cc_trust_data but these were not generally exposed by
the earlier interface.
