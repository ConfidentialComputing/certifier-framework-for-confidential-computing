// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: certifier.proto

#include "certifier.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR time_point::time_point(
    ::_pbi::ConstantInitialized)
  : year_(0)
  , month_(0)
  , day_(0)
  , hour_(0)
  , seconds_(0)
  , minute_(0){}
struct time_pointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR time_pointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~time_pointDefaultTypeInternal() {}
  union {
    time_point _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 time_pointDefaultTypeInternal _time_point_default_instance_;
PROTOBUF_CONSTEXPR rsa_message::rsa_message(
    ::_pbi::ConstantInitialized)
  : public_modulus_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , public_exponent_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , private_exponent_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , private_p_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , private_q_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , private_dp_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , private_dq_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct rsa_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR rsa_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~rsa_messageDefaultTypeInternal() {}
  union {
    rsa_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 rsa_messageDefaultTypeInternal _rsa_message_default_instance_;
PROTOBUF_CONSTEXPR point_message::point_message(
    ::_pbi::ConstantInitialized)
  : x_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , y_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct point_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR point_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~point_messageDefaultTypeInternal() {}
  union {
    point_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 point_messageDefaultTypeInternal _point_message_default_instance_;
PROTOBUF_CONSTEXPR ecc_message::ecc_message(
    ::_pbi::ConstantInitialized)
  : curve_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , curve_p_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , curve_a_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , curve_b_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , order_of_base_point_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , private_multiplier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , base_point_(nullptr)
  , public_point_(nullptr){}
struct ecc_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ecc_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ecc_messageDefaultTypeInternal() {}
  union {
    ecc_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ecc_messageDefaultTypeInternal _ecc_message_default_instance_;
PROTOBUF_CONSTEXPR key_message::key_message(
    ::_pbi::ConstantInitialized)
  : key_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , key_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , key_format_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , secret_key_bits_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , certificate_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , other_key_formats_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , not_before_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , not_after_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rsa_key_(nullptr)
  , ecc_key_(nullptr){}
struct key_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR key_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~key_messageDefaultTypeInternal() {}
  union {
    key_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 key_messageDefaultTypeInternal _key_message_default_instance_;
PROTOBUF_CONSTEXPR protected_blob_message::protected_blob_message(
    ::_pbi::ConstantInitialized)
  : encrypted_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , encrypted_data_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct protected_blob_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR protected_blob_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~protected_blob_messageDefaultTypeInternal() {}
  union {
    protected_blob_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 protected_blob_messageDefaultTypeInternal _protected_blob_message_default_instance_;
PROTOBUF_CONSTEXPR entity_message::entity_message(
    ::_pbi::ConstantInitialized)
  : entity_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , measurement_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , key_(nullptr){}
struct entity_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR entity_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~entity_messageDefaultTypeInternal() {}
  union {
    entity_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 entity_messageDefaultTypeInternal _entity_message_default_instance_;
PROTOBUF_CONSTEXPR vse_clause::vse_clause(
    ::_pbi::ConstantInitialized)
  : verb_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , subject_(nullptr)
  , object_(nullptr)
  , clause_(nullptr){}
struct vse_clauseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR vse_clauseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~vse_clauseDefaultTypeInternal() {}
  union {
    vse_clause _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 vse_clauseDefaultTypeInternal _vse_clause_default_instance_;
PROTOBUF_CONSTEXPR vse_clauses::vse_clauses(
    ::_pbi::ConstantInitialized)
  : clauses_(){}
struct vse_clausesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR vse_clausesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~vse_clausesDefaultTypeInternal() {}
  union {
    vse_clauses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 vse_clausesDefaultTypeInternal _vse_clauses_default_instance_;
PROTOBUF_CONSTEXPR claim_message::claim_message(
    ::_pbi::ConstantInitialized)
  : claim_format_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , claim_descriptor_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , not_before_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , not_after_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , serialized_claim_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct claim_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR claim_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~claim_messageDefaultTypeInternal() {}
  union {
    claim_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 claim_messageDefaultTypeInternal _claim_message_default_instance_;
PROTOBUF_CONSTEXPR attestation_user_data::attestation_user_data(
    ::_pbi::ConstantInitialized)
  : enclave_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , time_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , enclave_key_(nullptr)
  , policy_key_(nullptr){}
struct attestation_user_dataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR attestation_user_dataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~attestation_user_dataDefaultTypeInternal() {}
  union {
    attestation_user_data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 attestation_user_dataDefaultTypeInternal _attestation_user_data_default_instance_;
PROTOBUF_CONSTEXPR vse_attestation_report_info::vse_attestation_report_info(
    ::_pbi::ConstantInitialized)
  : enclave_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , verified_measurement_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , not_before_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , not_after_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_data_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct vse_attestation_report_infoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR vse_attestation_report_infoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~vse_attestation_report_infoDefaultTypeInternal() {}
  union {
    vse_attestation_report_info _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 vse_attestation_report_infoDefaultTypeInternal _vse_attestation_report_info_default_instance_;
PROTOBUF_CONSTEXPR signed_report::signed_report(
    ::_pbi::ConstantInitialized)
  : report_format_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , report_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , signing_algorithm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , signature_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , signing_key_(nullptr){}
struct signed_reportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR signed_reportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~signed_reportDefaultTypeInternal() {}
  union {
    signed_report _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 signed_reportDefaultTypeInternal _signed_report_default_instance_;
PROTOBUF_CONSTEXPR signed_claim_message::signed_claim_message(
    ::_pbi::ConstantInitialized)
  : serialized_claim_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , signing_algorithm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , signature_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , signing_key_(nullptr){}
struct signed_claim_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR signed_claim_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~signed_claim_messageDefaultTypeInternal() {}
  union {
    signed_claim_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 signed_claim_messageDefaultTypeInternal _signed_claim_message_default_instance_;
PROTOBUF_CONSTEXPR evidence::evidence(
    ::_pbi::ConstantInitialized)
  : evidence_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , serialized_evidence_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct evidenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR evidenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~evidenceDefaultTypeInternal() {}
  union {
    evidence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 evidenceDefaultTypeInternal _evidence_default_instance_;
PROTOBUF_CONSTEXPR evidence_list::evidence_list(
    ::_pbi::ConstantInitialized)
  : assertion_(){}
struct evidence_listDefaultTypeInternal {
  PROTOBUF_CONSTEXPR evidence_listDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~evidence_listDefaultTypeInternal() {}
  union {
    evidence_list _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 evidence_listDefaultTypeInternal _evidence_list_default_instance_;
PROTOBUF_CONSTEXPR sev_attestation_message::sev_attestation_message(
    ::_pbi::ConstantInitialized)
  : what_was_said_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , reported_attestation_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct sev_attestation_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR sev_attestation_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~sev_attestation_messageDefaultTypeInternal() {}
  union {
    sev_attestation_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 sev_attestation_messageDefaultTypeInternal _sev_attestation_message_default_instance_;
PROTOBUF_CONSTEXPR evidence_package::evidence_package(
    ::_pbi::ConstantInitialized)
  : fact_assertion_()
  , prover_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct evidence_packageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR evidence_packageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~evidence_packageDefaultTypeInternal() {}
  union {
    evidence_package _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 evidence_packageDefaultTypeInternal _evidence_package_default_instance_;
PROTOBUF_CONSTEXPR certifier_rules::certifier_rules(
    ::_pbi::ConstantInitialized)
  : rule_(){}
struct certifier_rulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR certifier_rulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~certifier_rulesDefaultTypeInternal() {}
  union {
    certifier_rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 certifier_rulesDefaultTypeInternal _certifier_rules_default_instance_;
PROTOBUF_CONSTEXPR proved_statements::proved_statements(
    ::_pbi::ConstantInitialized)
  : proved_(){}
struct proved_statementsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR proved_statementsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~proved_statementsDefaultTypeInternal() {}
  union {
    proved_statements _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 proved_statementsDefaultTypeInternal _proved_statements_default_instance_;
PROTOBUF_CONSTEXPR proof_step::proof_step(
    ::_pbi::ConstantInitialized)
  : s1_(nullptr)
  , s2_(nullptr)
  , conclusion_(nullptr)
  , rule_applied_(0){}
struct proof_stepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR proof_stepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~proof_stepDefaultTypeInternal() {}
  union {
    proof_step _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 proof_stepDefaultTypeInternal _proof_step_default_instance_;
PROTOBUF_CONSTEXPR proof::proof(
    ::_pbi::ConstantInitialized)
  : already_proved_()
  , steps_()
  , to_prove_(nullptr){}
struct proofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR proofDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~proofDefaultTypeInternal() {}
  union {
    proof _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 proofDefaultTypeInternal _proof_default_instance_;
PROTOBUF_CONSTEXPR trust_request_message::trust_request_message(
    ::_pbi::ConstantInitialized)
  : requesting_enclave_tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , providing_enclave_tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , submitted_evidence_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , purpose_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , support_(nullptr){}
struct trust_request_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR trust_request_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~trust_request_messageDefaultTypeInternal() {}
  union {
    trust_request_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 trust_request_messageDefaultTypeInternal _trust_request_message_default_instance_;
PROTOBUF_CONSTEXPR trust_response_message::trust_response_message(
    ::_pbi::ConstantInitialized)
  : status_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , requesting_enclave_tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , providing_enclave_tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , artifact_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct trust_response_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR trust_response_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~trust_response_messageDefaultTypeInternal() {}
  union {
    trust_response_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 trust_response_messageDefaultTypeInternal _trust_response_message_default_instance_;
PROTOBUF_CONSTEXPR storage_info_message::storage_info_message(
    ::_pbi::ConstantInitialized)
  : storage_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , storage_descriptor_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , address_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , storage_key_(nullptr){}
struct storage_info_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR storage_info_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~storage_info_messageDefaultTypeInternal() {}
  union {
    storage_info_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 storage_info_messageDefaultTypeInternal _storage_info_message_default_instance_;
PROTOBUF_CONSTEXPR channel_key_message::channel_key_message(
    ::_pbi::ConstantInitialized)
  : tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , auth_key_(nullptr){}
struct channel_key_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR channel_key_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~channel_key_messageDefaultTypeInternal() {}
  union {
    channel_key_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 channel_key_messageDefaultTypeInternal _channel_key_message_default_instance_;
PROTOBUF_CONSTEXPR trusted_service_message::trusted_service_message(
    ::_pbi::ConstantInitialized)
  : trusted_service_address_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , trusted_service_key_(nullptr){}
struct trusted_service_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR trusted_service_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~trusted_service_messageDefaultTypeInternal() {}
  union {
    trusted_service_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 trusted_service_messageDefaultTypeInternal _trusted_service_message_default_instance_;
PROTOBUF_CONSTEXPR tagged_claim::tagged_claim(
    ::_pbi::ConstantInitialized)
  : tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , claim_(nullptr){}
struct tagged_claimDefaultTypeInternal {
  PROTOBUF_CONSTEXPR tagged_claimDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~tagged_claimDefaultTypeInternal() {}
  union {
    tagged_claim _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 tagged_claimDefaultTypeInternal _tagged_claim_default_instance_;
PROTOBUF_CONSTEXPR tagged_claims_sequence::tagged_claims_sequence(
    ::_pbi::ConstantInitialized)
  : claims_(){}
struct tagged_claims_sequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR tagged_claims_sequenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~tagged_claims_sequenceDefaultTypeInternal() {}
  union {
    tagged_claims_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 tagged_claims_sequenceDefaultTypeInternal _tagged_claims_sequence_default_instance_;
PROTOBUF_CONSTEXPR policy_store_message::policy_store_message(
    ::_pbi::ConstantInitialized)
  : trusted_services_()
  , channel_authentication_keys_()
  , claims_()
  , storage_info_()
  , signed_claims_()
  , blobs_()
  , policy_key_(nullptr){}
struct policy_store_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR policy_store_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~policy_store_messageDefaultTypeInternal() {}
  union {
    policy_store_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 policy_store_messageDefaultTypeInternal _policy_store_message_default_instance_;
PROTOBUF_CONSTEXPR claims_sequence::claims_sequence(
    ::_pbi::ConstantInitialized)
  : claims_(){}
struct claims_sequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR claims_sequenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~claims_sequenceDefaultTypeInternal() {}
  union {
    claims_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 claims_sequenceDefaultTypeInternal _claims_sequence_default_instance_;
PROTOBUF_CONSTEXPR signed_claim_sequence::signed_claim_sequence(
    ::_pbi::ConstantInitialized)
  : claims_(){}
struct signed_claim_sequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR signed_claim_sequenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~signed_claim_sequenceDefaultTypeInternal() {}
  union {
    signed_claim_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 signed_claim_sequenceDefaultTypeInternal _signed_claim_sequence_default_instance_;
PROTOBUF_CONSTEXPR tagged_signed_claim::tagged_signed_claim(
    ::_pbi::ConstantInitialized)
  : tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sc_(nullptr){}
struct tagged_signed_claimDefaultTypeInternal {
  PROTOBUF_CONSTEXPR tagged_signed_claimDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~tagged_signed_claimDefaultTypeInternal() {}
  union {
    tagged_signed_claim _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 tagged_signed_claimDefaultTypeInternal _tagged_signed_claim_default_instance_;
PROTOBUF_CONSTEXPR buffer_sequence::buffer_sequence(
    ::_pbi::ConstantInitialized)
  : block_(){}
struct buffer_sequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR buffer_sequenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~buffer_sequenceDefaultTypeInternal() {}
  union {
    buffer_sequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 buffer_sequenceDefaultTypeInternal _buffer_sequence_default_instance_;
PROTOBUF_CONSTEXPR run_request::run_request(
    ::_pbi::ConstantInitialized)
  : args_()
  , location_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , cert_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct run_requestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR run_requestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~run_requestDefaultTypeInternal() {}
  union {
    run_request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 run_requestDefaultTypeInternal _run_request_default_instance_;
PROTOBUF_CONSTEXPR run_response::run_response(
    ::_pbi::ConstantInitialized)
  : status_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct run_responseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR run_responseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~run_responseDefaultTypeInternal() {}
  union {
    run_response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 run_responseDefaultTypeInternal _run_response_default_instance_;
PROTOBUF_CONSTEXPR app_request::app_request(
    ::_pbi::ConstantInitialized)
  : args_()
  , function_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct app_requestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR app_requestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~app_requestDefaultTypeInternal() {}
  union {
    app_request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 app_requestDefaultTypeInternal _app_request_default_instance_;
PROTOBUF_CONSTEXPR app_response::app_response(
    ::_pbi::ConstantInitialized)
  : args_()
  , function_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , status_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct app_responseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR app_responseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~app_responseDefaultTypeInternal() {}
  union {
    app_response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 app_responseDefaultTypeInternal _app_response_default_instance_;
PROTOBUF_CONSTEXPR tagged_blob_message::tagged_blob_message(
    ::_pbi::ConstantInitialized)
  : tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , b_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct tagged_blob_messageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR tagged_blob_messageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~tagged_blob_messageDefaultTypeInternal() {}
  union {
    tagged_blob_message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 tagged_blob_messageDefaultTypeInternal _tagged_blob_message_default_instance_;
static ::_pb::Metadata file_level_metadata_certifier_2eproto[39];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_certifier_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_certifier_2eproto = nullptr;

const uint32_t TableStruct_certifier_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::time_point, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::time_point, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::time_point, year_),
  PROTOBUF_FIELD_OFFSET(::time_point, month_),
  PROTOBUF_FIELD_OFFSET(::time_point, day_),
  PROTOBUF_FIELD_OFFSET(::time_point, hour_),
  PROTOBUF_FIELD_OFFSET(::time_point, minute_),
  PROTOBUF_FIELD_OFFSET(::time_point, seconds_),
  0,
  1,
  2,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::rsa_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rsa_message, public_modulus_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, public_exponent_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, private_exponent_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, private_p_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, private_q_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, private_dp_),
  PROTOBUF_FIELD_OFFSET(::rsa_message, private_dq_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::point_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::point_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::point_message, x_),
  PROTOBUF_FIELD_OFFSET(::point_message, y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ecc_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ecc_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ecc_message, curve_name_),
  PROTOBUF_FIELD_OFFSET(::ecc_message, curve_p_),
  PROTOBUF_FIELD_OFFSET(::ecc_message, curve_a_),
  PROTOBUF_FIELD_OFFSET(::ecc_message, curve_b_),
  PROTOBUF_FIELD_OFFSET(::ecc_message, base_point_),
  PROTOBUF_FIELD_OFFSET(::ecc_message, public_point_),
  PROTOBUF_FIELD_OFFSET(::ecc_message, order_of_base_point_),
  PROTOBUF_FIELD_OFFSET(::ecc_message, private_multiplier_),
  0,
  1,
  2,
  3,
  6,
  7,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::key_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::key_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::key_message, key_name_),
  PROTOBUF_FIELD_OFFSET(::key_message, key_type_),
  PROTOBUF_FIELD_OFFSET(::key_message, key_format_),
  PROTOBUF_FIELD_OFFSET(::key_message, rsa_key_),
  PROTOBUF_FIELD_OFFSET(::key_message, ecc_key_),
  PROTOBUF_FIELD_OFFSET(::key_message, secret_key_bits_),
  PROTOBUF_FIELD_OFFSET(::key_message, certificate_),
  PROTOBUF_FIELD_OFFSET(::key_message, other_key_formats_),
  PROTOBUF_FIELD_OFFSET(::key_message, not_before_),
  PROTOBUF_FIELD_OFFSET(::key_message, not_after_),
  0,
  1,
  2,
  8,
  9,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, encrypted_key_),
  PROTOBUF_FIELD_OFFSET(::protected_blob_message, encrypted_data_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::entity_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::entity_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::entity_message, entity_type_),
  PROTOBUF_FIELD_OFFSET(::entity_message, key_),
  PROTOBUF_FIELD_OFFSET(::entity_message, measurement_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::vse_clause, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vse_clause, subject_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, verb_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, object_),
  PROTOBUF_FIELD_OFFSET(::vse_clause, clause_),
  1,
  0,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vse_clauses, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vse_clauses, clauses_),
  PROTOBUF_FIELD_OFFSET(::claim_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::claim_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::claim_message, claim_format_),
  PROTOBUF_FIELD_OFFSET(::claim_message, claim_descriptor_),
  PROTOBUF_FIELD_OFFSET(::claim_message, not_before_),
  PROTOBUF_FIELD_OFFSET(::claim_message, not_after_),
  PROTOBUF_FIELD_OFFSET(::claim_message, serialized_claim_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::attestation_user_data, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::attestation_user_data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::attestation_user_data, enclave_type_),
  PROTOBUF_FIELD_OFFSET(::attestation_user_data, time_),
  PROTOBUF_FIELD_OFFSET(::attestation_user_data, enclave_key_),
  PROTOBUF_FIELD_OFFSET(::attestation_user_data, policy_key_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::vse_attestation_report_info, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vse_attestation_report_info, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vse_attestation_report_info, enclave_type_),
  PROTOBUF_FIELD_OFFSET(::vse_attestation_report_info, verified_measurement_),
  PROTOBUF_FIELD_OFFSET(::vse_attestation_report_info, not_before_),
  PROTOBUF_FIELD_OFFSET(::vse_attestation_report_info, not_after_),
  PROTOBUF_FIELD_OFFSET(::vse_attestation_report_info, user_data_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::signed_report, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::signed_report, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::signed_report, report_format_),
  PROTOBUF_FIELD_OFFSET(::signed_report, report_),
  PROTOBUF_FIELD_OFFSET(::signed_report, signing_key_),
  PROTOBUF_FIELD_OFFSET(::signed_report, signing_algorithm_),
  PROTOBUF_FIELD_OFFSET(::signed_report, signature_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, serialized_claim_message_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, signing_key_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, signing_algorithm_),
  PROTOBUF_FIELD_OFFSET(::signed_claim_message, signature_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::evidence, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::evidence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::evidence, evidence_type_),
  PROTOBUF_FIELD_OFFSET(::evidence, serialized_evidence_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::evidence_list, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::evidence_list, assertion_),
  PROTOBUF_FIELD_OFFSET(::sev_attestation_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::sev_attestation_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sev_attestation_message, what_was_said_),
  PROTOBUF_FIELD_OFFSET(::sev_attestation_message, reported_attestation_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::evidence_package, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::evidence_package, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::evidence_package, prover_type_),
  PROTOBUF_FIELD_OFFSET(::evidence_package, fact_assertion_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::certifier_rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::certifier_rules, rule_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proved_statements, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proved_statements, proved_),
  PROTOBUF_FIELD_OFFSET(::proof_step, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proof_step, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proof_step, s1_),
  PROTOBUF_FIELD_OFFSET(::proof_step, s2_),
  PROTOBUF_FIELD_OFFSET(::proof_step, conclusion_),
  PROTOBUF_FIELD_OFFSET(::proof_step, rule_applied_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::proof, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proof, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proof, to_prove_),
  PROTOBUF_FIELD_OFFSET(::proof, already_proved_),
  PROTOBUF_FIELD_OFFSET(::proof, steps_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::trust_request_message, requesting_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, providing_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, submitted_evidence_type_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, purpose_),
  PROTOBUF_FIELD_OFFSET(::trust_request_message, support_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::trust_response_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::trust_response_message, status_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, requesting_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, providing_enclave_tag_),
  PROTOBUF_FIELD_OFFSET(::trust_response_message, artifact_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::storage_info_message, storage_type_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, storage_descriptor_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, address_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, storage_key_),
  PROTOBUF_FIELD_OFFSET(::storage_info_message, tag_),
  0,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::channel_key_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::channel_key_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::channel_key_message, tag_),
  PROTOBUF_FIELD_OFFSET(::channel_key_message, auth_key_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, trusted_service_address_),
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, trusted_service_key_),
  PROTOBUF_FIELD_OFFSET(::trusted_service_message, tag_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::tagged_claim, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::tagged_claim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tagged_claim, tag_),
  PROTOBUF_FIELD_OFFSET(::tagged_claim, claim_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tagged_claims_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tagged_claims_sequence, claims_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::policy_store_message, policy_key_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, trusted_services_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, channel_authentication_keys_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, claims_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, storage_info_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, signed_claims_),
  PROTOBUF_FIELD_OFFSET(::policy_store_message, blobs_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::claims_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::claims_sequence, claims_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::signed_claim_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::signed_claim_sequence, claims_),
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, tag_),
  PROTOBUF_FIELD_OFFSET(::tagged_signed_claim, sc_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::buffer_sequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::buffer_sequence, block_),
  PROTOBUF_FIELD_OFFSET(::run_request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::run_request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::run_request, location_),
  PROTOBUF_FIELD_OFFSET(::run_request, cert_),
  PROTOBUF_FIELD_OFFSET(::run_request, args_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::run_response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::run_response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::run_response, status_),
  0,
  PROTOBUF_FIELD_OFFSET(::app_request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::app_request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::app_request, function_),
  PROTOBUF_FIELD_OFFSET(::app_request, args_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::app_response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::app_response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::app_response, function_),
  PROTOBUF_FIELD_OFFSET(::app_response, status_),
  PROTOBUF_FIELD_OFFSET(::app_response, args_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, tag_),
  PROTOBUF_FIELD_OFFSET(::tagged_blob_message, b_),
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, -1, sizeof(::time_point)},
  { 18, 31, -1, sizeof(::rsa_message)},
  { 38, 46, -1, sizeof(::point_message)},
  { 48, 62, -1, sizeof(::ecc_message)},
  { 70, 86, -1, sizeof(::key_message)},
  { 96, 104, -1, sizeof(::protected_blob_message)},
  { 106, 115, -1, sizeof(::entity_message)},
  { 118, 128, -1, sizeof(::vse_clause)},
  { 132, -1, -1, sizeof(::vse_clauses)},
  { 139, 150, -1, sizeof(::claim_message)},
  { 155, 165, -1, sizeof(::attestation_user_data)},
  { 169, 180, -1, sizeof(::vse_attestation_report_info)},
  { 185, 196, -1, sizeof(::signed_report)},
  { 201, 211, -1, sizeof(::signed_claim_message)},
  { 215, 223, -1, sizeof(::evidence)},
  { 225, -1, -1, sizeof(::evidence_list)},
  { 232, 240, -1, sizeof(::sev_attestation_message)},
  { 242, 250, -1, sizeof(::evidence_package)},
  { 252, -1, -1, sizeof(::certifier_rules)},
  { 259, -1, -1, sizeof(::proved_statements)},
  { 266, 276, -1, sizeof(::proof_step)},
  { 280, 289, -1, sizeof(::proof)},
  { 292, 303, -1, sizeof(::trust_request_message)},
  { 308, 318, -1, sizeof(::trust_response_message)},
  { 322, 333, -1, sizeof(::storage_info_message)},
  { 338, 346, -1, sizeof(::channel_key_message)},
  { 348, 357, -1, sizeof(::trusted_service_message)},
  { 360, 368, -1, sizeof(::tagged_claim)},
  { 370, -1, -1, sizeof(::tagged_claims_sequence)},
  { 377, 390, -1, sizeof(::policy_store_message)},
  { 397, -1, -1, sizeof(::claims_sequence)},
  { 404, -1, -1, sizeof(::signed_claim_sequence)},
  { 411, 419, -1, sizeof(::tagged_signed_claim)},
  { 421, -1, -1, sizeof(::buffer_sequence)},
  { 428, 437, -1, sizeof(::run_request)},
  { 440, 447, -1, sizeof(::run_response)},
  { 448, 456, -1, sizeof(::app_request)},
  { 458, 467, -1, sizeof(::app_response)},
  { 470, 478, -1, sizeof(::tagged_blob_message)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_time_point_default_instance_._instance,
  &::_rsa_message_default_instance_._instance,
  &::_point_message_default_instance_._instance,
  &::_ecc_message_default_instance_._instance,
  &::_key_message_default_instance_._instance,
  &::_protected_blob_message_default_instance_._instance,
  &::_entity_message_default_instance_._instance,
  &::_vse_clause_default_instance_._instance,
  &::_vse_clauses_default_instance_._instance,
  &::_claim_message_default_instance_._instance,
  &::_attestation_user_data_default_instance_._instance,
  &::_vse_attestation_report_info_default_instance_._instance,
  &::_signed_report_default_instance_._instance,
  &::_signed_claim_message_default_instance_._instance,
  &::_evidence_default_instance_._instance,
  &::_evidence_list_default_instance_._instance,
  &::_sev_attestation_message_default_instance_._instance,
  &::_evidence_package_default_instance_._instance,
  &::_certifier_rules_default_instance_._instance,
  &::_proved_statements_default_instance_._instance,
  &::_proof_step_default_instance_._instance,
  &::_proof_default_instance_._instance,
  &::_trust_request_message_default_instance_._instance,
  &::_trust_response_message_default_instance_._instance,
  &::_storage_info_message_default_instance_._instance,
  &::_channel_key_message_default_instance_._instance,
  &::_trusted_service_message_default_instance_._instance,
  &::_tagged_claim_default_instance_._instance,
  &::_tagged_claims_sequence_default_instance_._instance,
  &::_policy_store_message_default_instance_._instance,
  &::_claims_sequence_default_instance_._instance,
  &::_signed_claim_sequence_default_instance_._instance,
  &::_tagged_signed_claim_default_instance_._instance,
  &::_buffer_sequence_default_instance_._instance,
  &::_run_request_default_instance_._instance,
  &::_run_response_default_instance_._instance,
  &::_app_request_default_instance_._instance,
  &::_app_response_default_instance_._instance,
  &::_tagged_blob_message_default_instance_._instance,
};

const char descriptor_table_protodef_certifier_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017certifier.proto\"e\n\ntime_point\022\014\n\004year\030"
  "\001 \001(\005\022\r\n\005month\030\002 \001(\005\022\013\n\003day\030\003 \001(\005\022\014\n\004hou"
  "r\030\004 \001(\005\022\016\n\006minute\030\005 \001(\005\022\017\n\007seconds\030\006 \001(\001"
  "\"\246\001\n\013rsa_message\022\026\n\016public_modulus\030\001 \001(\014"
  "\022\027\n\017public_exponent\030\002 \001(\014\022\030\n\020private_exp"
  "onent\030\003 \001(\014\022\021\n\tprivate_p\030\004 \001(\014\022\021\n\tprivat"
  "e_q\030\005 \001(\014\022\022\n\nprivate_dp\030\006 \001(\014\022\022\n\nprivate"
  "_dq\030\007 \001(\014\"%\n\rpoint_message\022\t\n\001x\030\001 \001(\014\022\t\n"
  "\001y\030\002 \001(\014\"\327\001\n\013ecc_message\022\022\n\ncurve_name\030\001"
  " \001(\t\022\017\n\007curve_p\030\002 \001(\014\022\017\n\007curve_a\030\003 \001(\014\022\017"
  "\n\007curve_b\030\004 \001(\014\022\"\n\nbase_point\030\005 \001(\0132\016.po"
  "int_message\022$\n\014public_point\030\006 \001(\0132\016.poin"
  "t_message\022\033\n\023order_of_base_point\030\007 \001(\014\022\032"
  "\n\022private_multiplier\030\010 \001(\014\"\363\001\n\013key_messa"
  "ge\022\020\n\010key_name\030\001 \001(\t\022\020\n\010key_type\030\002 \001(\t\022\022"
  "\n\nkey_format\030\003 \001(\t\022\035\n\007rsa_key\030\004 \001(\0132\014.rs"
  "a_message\022\035\n\007ecc_key\030\005 \001(\0132\014.ecc_message"
  "\022\027\n\017secret_key_bits\030\006 \001(\014\022\023\n\013certificate"
  "\030\007 \001(\014\022\031\n\021other_key_formats\030\010 \001(\014\022\022\n\nnot"
  "_before\030\t \001(\t\022\021\n\tnot_after\030\n \001(\t\"G\n\026prot"
  "ected_blob_message\022\025\n\rencrypted_key\030\001 \001("
  "\014\022\026\n\016encrypted_data\030\002 \001(\014\"U\n\016entity_mess"
  "age\022\023\n\013entity_type\030\001 \001(\t\022\031\n\003key\030\002 \001(\0132\014."
  "key_message\022\023\n\013measurement\030\003 \001(\014\"z\n\nvse_"
  "clause\022 \n\007subject\030\001 \001(\0132\017.entity_message"
  "\022\014\n\004verb\030\002 \001(\t\022\037\n\006object\030\003 \001(\0132\017.entity_"
  "message\022\033\n\006clause\030\004 \001(\0132\013.vse_clause\"+\n\013"
  "vse_clauses\022\034\n\007clauses\030\001 \003(\0132\013.vse_claus"
  "e\"\200\001\n\rclaim_message\022\024\n\014claim_format\030\001 \001("
  "\t\022\030\n\020claim_descriptor\030\002 \001(\t\022\022\n\nnot_befor"
  "e\030\003 \001(\t\022\021\n\tnot_after\030\004 \001(\t\022\030\n\020serialized"
  "_claim\030\005 \001(\014\"\200\001\n\025attestation_user_data\022\024"
  "\n\014enclave_type\030\001 \001(\t\022\014\n\004time\030\002 \001(\t\022!\n\013en"
  "clave_key\030\003 \001(\0132\014.key_message\022 \n\npolicy_"
  "key\030\004 \001(\0132\014.key_message\"\213\001\n\033vse_attestat"
  "ion_report_info\022\024\n\014enclave_type\030\001 \001(\t\022\034\n"
  "\024verified_measurement\030\002 \001(\014\022\022\n\nnot_befor"
  "e\030\003 \001(\t\022\021\n\tnot_after\030\004 \001(\t\022\021\n\tuser_data\030"
  "\005 \001(\014\"\207\001\n\rsigned_report\022\025\n\rreport_format"
  "\030\001 \001(\t\022\016\n\006report\030\002 \001(\014\022!\n\013signing_key\030\003 "
  "\001(\0132\014.key_message\022\031\n\021signing_algorithm\030\004"
  " \001(\t\022\021\n\tsignature\030\005 \001(\014\"\211\001\n\024signed_claim"
  "_message\022 \n\030serialized_claim_message\030\001 \001"
  "(\014\022!\n\013signing_key\030\002 \001(\0132\014.key_message\022\031\n"
  "\021signing_algorithm\030\003 \001(\t\022\021\n\tsignature\030\004 "
  "\001(\014\">\n\010evidence\022\025\n\revidence_type\030\001 \001(\t\022\033"
  "\n\023serialized_evidence\030\002 \001(\014\"-\n\revidence_"
  "list\022\034\n\tassertion\030\001 \003(\0132\t.evidence\"N\n\027se"
  "v_attestation_message\022\025\n\rwhat_was_said\030\001"
  " \001(\014\022\034\n\024reported_attestation\030\002 \001(\014\"J\n\020ev"
  "idence_package\022\023\n\013prover_type\030\001 \001(\t\022!\n\016f"
  "act_assertion\030\002 \003(\0132\t.evidence\"\037\n\017certif"
  "ier_rules\022\014\n\004rule\030\001 \003(\t\"0\n\021proved_statem"
  "ents\022\033\n\006proved\030\001 \003(\0132\013.vse_clause\"u\n\npro"
  "of_step\022\027\n\002s1\030\001 \001(\0132\013.vse_clause\022\027\n\002s2\030\002"
  " \001(\0132\013.vse_clause\022\037\n\nconclusion\030\003 \001(\0132\013."
  "vse_clause\022\024\n\014rule_applied\030\004 \001(\005\"g\n\005proo"
  "f\022\035\n\010to_prove\030\001 \001(\0132\013.vse_clause\022#\n\016alre"
  "ady_proved\030\002 \003(\0132\013.vse_clause\022\032\n\005steps\030\003"
  " \003(\0132\013.proof_step\"\254\001\n\025trust_request_mess"
  "age\022\036\n\026requesting_enclave_tag\030\001 \001(\t\022\035\n\025p"
  "roviding_enclave_tag\030\002 \001(\t\022\037\n\027submitted_"
  "evidence_type\030\003 \001(\t\022\017\n\007purpose\030\004 \001(\t\022\"\n\007"
  "support\030\005 \001(\0132\021.evidence_package\"y\n\026trus"
  "t_response_message\022\016\n\006status\030\001 \001(\t\022\036\n\026re"
  "questing_enclave_tag\030\002 \001(\t\022\035\n\025providing_"
  "enclave_tag\030\003 \001(\t\022\020\n\010artifact\030\004 \001(\014\"\211\001\n\024"
  "storage_info_message\022\024\n\014storage_type\030\001 \001"
  "(\t\022\032\n\022storage_descriptor\030\002 \001(\t\022\017\n\007addres"
  "s\030\003 \001(\t\022!\n\013storage_key\030\004 \001(\0132\014.key_messa"
  "ge\022\013\n\003tag\030\005 \001(\t\"B\n\023channel_key_message\022\013"
  "\n\003tag\030\001 \001(\t\022\036\n\010auth_key\030\002 \001(\0132\014.key_mess"
  "age\"r\n\027trusted_service_message\022\037\n\027truste"
  "d_service_address\030\001 \001(\t\022)\n\023trusted_servi"
  "ce_key\030\002 \001(\0132\014.key_message\022\013\n\003tag\030\003 \001(\t\""
  ":\n\014tagged_claim\022\013\n\003tag\030\001 \001(\t\022\035\n\005claim\030\002 "
  "\001(\0132\016.claim_message\"7\n\026tagged_claims_seq"
  "uence\022\035\n\006claims\030\001 \003(\0132\r.tagged_claim\"\305\002\n"
  "\024policy_store_message\022 \n\npolicy_key\030\001 \001("
  "\0132\014.key_message\0222\n\020trusted_services\030\002 \003("
  "\0132\030.trusted_service_message\0229\n\033channel_a"
  "uthentication_keys\030\003 \003(\0132\024.channel_key_m"
  "essage\022\035\n\006claims\030\004 \003(\0132\r.tagged_claim\022+\n"
  "\014storage_info\030\005 \003(\0132\025.storage_info_messa"
  "ge\022+\n\rsigned_claims\030\006 \003(\0132\024.tagged_signe"
  "d_claim\022#\n\005blobs\030\007 \003(\0132\024.tagged_blob_mes"
  "sage\"1\n\017claims_sequence\022\036\n\006claims\030\001 \003(\0132"
  "\016.claim_message\">\n\025signed_claim_sequence"
  "\022%\n\006claims\030\001 \003(\0132\025.signed_claim_message\""
  "E\n\023tagged_signed_claim\022\013\n\003tag\030\001 \001(\t\022!\n\002s"
  "c\030\002 \001(\0132\025.signed_claim_message\" \n\017buffer"
  "_sequence\022\r\n\005block\030\001 \003(\014\";\n\013run_request\022"
  "\020\n\010location\030\001 \001(\t\022\014\n\004cert\030\002 \001(\014\022\014\n\004args\030"
  "\003 \003(\t\"\036\n\014run_response\022\016\n\006status\030\001 \001(\t\"-\n"
  "\013app_request\022\020\n\010function\030\001 \001(\t\022\014\n\004args\030\002"
  " \003(\014\">\n\014app_response\022\020\n\010function\030\001 \001(\t\022\016"
  "\n\006status\030\002 \001(\t\022\014\n\004args\030\003 \003(\014\"-\n\023tagged_b"
  "lob_message\022\013\n\003tag\030\001 \001(\t\022\t\n\001b\030\002 \001(\014"
  ;
static ::_pbi::once_flag descriptor_table_certifier_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_certifier_2eproto = {
    false, false, 3915, descriptor_table_protodef_certifier_2eproto,
    "certifier.proto",
    &descriptor_table_certifier_2eproto_once, nullptr, 0, 39,
    schemas, file_default_instances, TableStruct_certifier_2eproto::offsets,
    file_level_metadata_certifier_2eproto, file_level_enum_descriptors_certifier_2eproto,
    file_level_service_descriptors_certifier_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_certifier_2eproto_getter() {
  return &descriptor_table_certifier_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_certifier_2eproto(&descriptor_table_certifier_2eproto);

// ===================================================================

class time_point::_Internal {
 public:
  using HasBits = decltype(std::declval<time_point>()._has_bits_);
  static void set_has_year(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_month(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_day(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hour(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_minute(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

time_point::time_point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:time_point)
}
time_point::time_point(const time_point& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&year_, &from.year_,
    static_cast<size_t>(reinterpret_cast<char*>(&minute_) -
    reinterpret_cast<char*>(&year_)) + sizeof(minute_));
  // @@protoc_insertion_point(copy_constructor:time_point)
}

inline void time_point::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&year_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&minute_) -
    reinterpret_cast<char*>(&year_)) + sizeof(minute_));
}

time_point::~time_point() {
  // @@protoc_insertion_point(destructor:time_point)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void time_point::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void time_point::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void time_point::Clear() {
// @@protoc_insertion_point(message_clear_start:time_point)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&year_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&minute_) -
        reinterpret_cast<char*>(&year_)) + sizeof(minute_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* time_point::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 year = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_year(&has_bits);
          year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 month = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_month(&has_bits);
          month_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 day = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_day(&has_bits);
          day_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 hour = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hour(&has_bits);
          hour_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 minute = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_minute(&has_bits);
          minute_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_seconds(&has_bits);
          seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* time_point::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:time_point)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 year = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_year(), target);
  }

  // optional int32 month = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_month(), target);
  }

  // optional int32 day = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_day(), target);
  }

  // optional int32 hour = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_hour(), target);
  }

  // optional int32 minute = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_minute(), target);
  }

  // optional double seconds = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:time_point)
  return target;
}

size_t time_point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:time_point)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int32 year = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_year());
    }

    // optional int32 month = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_month());
    }

    // optional int32 day = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_day());
    }

    // optional int32 hour = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hour());
    }

    // optional double seconds = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional int32 minute = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minute());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData time_point::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    time_point::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*time_point::GetClassData() const { return &_class_data_; }

void time_point::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<time_point *>(to)->MergeFrom(
      static_cast<const time_point &>(from));
}


void time_point::MergeFrom(const time_point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:time_point)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      year_ = from.year_;
    }
    if (cached_has_bits & 0x00000002u) {
      month_ = from.month_;
    }
    if (cached_has_bits & 0x00000004u) {
      day_ = from.day_;
    }
    if (cached_has_bits & 0x00000008u) {
      hour_ = from.hour_;
    }
    if (cached_has_bits & 0x00000010u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000020u) {
      minute_ = from.minute_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void time_point::CopyFrom(const time_point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:time_point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool time_point::IsInitialized() const {
  return true;
}

void time_point::InternalSwap(time_point* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(time_point, minute_)
      + sizeof(time_point::minute_)
      - PROTOBUF_FIELD_OFFSET(time_point, year_)>(
          reinterpret_cast<char*>(&year_),
          reinterpret_cast<char*>(&other->year_));
}

::PROTOBUF_NAMESPACE_ID::Metadata time_point::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[0]);
}

// ===================================================================

class rsa_message::_Internal {
 public:
  using HasBits = decltype(std::declval<rsa_message>()._has_bits_);
  static void set_has_public_modulus(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_public_exponent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_private_exponent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_private_p(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_private_q(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_private_dp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_private_dq(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

rsa_message::rsa_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:rsa_message)
}
rsa_message::rsa_message(const rsa_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  public_modulus_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    public_modulus_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_public_modulus()) {
    public_modulus_.Set(from._internal_public_modulus(), 
      GetArenaForAllocation());
  }
  public_exponent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    public_exponent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_public_exponent()) {
    public_exponent_.Set(from._internal_public_exponent(), 
      GetArenaForAllocation());
  }
  private_exponent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_exponent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_exponent()) {
    private_exponent_.Set(from._internal_private_exponent(), 
      GetArenaForAllocation());
  }
  private_p_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_p_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_p()) {
    private_p_.Set(from._internal_private_p(), 
      GetArenaForAllocation());
  }
  private_q_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_q_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_q()) {
    private_q_.Set(from._internal_private_q(), 
      GetArenaForAllocation());
  }
  private_dp_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_dp_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_dp()) {
    private_dp_.Set(from._internal_private_dp(), 
      GetArenaForAllocation());
  }
  private_dq_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_dq_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_dq()) {
    private_dq_.Set(from._internal_private_dq(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:rsa_message)
}

inline void rsa_message::SharedCtor() {
public_modulus_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  public_modulus_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
public_exponent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  public_exponent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_exponent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_exponent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_p_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_p_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_q_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_q_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_dp_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_dp_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_dq_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_dq_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

rsa_message::~rsa_message() {
  // @@protoc_insertion_point(destructor:rsa_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void rsa_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  public_modulus_.Destroy();
  public_exponent_.Destroy();
  private_exponent_.Destroy();
  private_p_.Destroy();
  private_q_.Destroy();
  private_dp_.Destroy();
  private_dq_.Destroy();
}

void rsa_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void rsa_message::Clear() {
// @@protoc_insertion_point(message_clear_start:rsa_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      public_modulus_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      public_exponent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      private_exponent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      private_p_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      private_q_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      private_dp_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      private_dq_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* rsa_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes public_modulus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_public_modulus();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes public_exponent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_public_exponent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_exponent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_private_exponent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_p = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_private_p();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_q = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_private_q();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_dp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_private_dp();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_dq = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_private_dq();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* rsa_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rsa_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes public_modulus = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_public_modulus(), target);
  }

  // optional bytes public_exponent = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_public_exponent(), target);
  }

  // optional bytes private_exponent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_private_exponent(), target);
  }

  // optional bytes private_p = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_private_p(), target);
  }

  // optional bytes private_q = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_private_q(), target);
  }

  // optional bytes private_dp = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_private_dp(), target);
  }

  // optional bytes private_dq = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_private_dq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rsa_message)
  return target;
}

size_t rsa_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rsa_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes public_modulus = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_public_modulus());
    }

    // optional bytes public_exponent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_public_exponent());
    }

    // optional bytes private_exponent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_exponent());
    }

    // optional bytes private_p = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_p());
    }

    // optional bytes private_q = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_q());
    }

    // optional bytes private_dp = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_dp());
    }

    // optional bytes private_dq = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_dq());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData rsa_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    rsa_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*rsa_message::GetClassData() const { return &_class_data_; }

void rsa_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<rsa_message *>(to)->MergeFrom(
      static_cast<const rsa_message &>(from));
}


void rsa_message::MergeFrom(const rsa_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rsa_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_public_modulus(from._internal_public_modulus());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_public_exponent(from._internal_public_exponent());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_private_exponent(from._internal_private_exponent());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_private_p(from._internal_private_p());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_private_q(from._internal_private_q());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_private_dp(from._internal_private_dp());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_private_dq(from._internal_private_dq());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void rsa_message::CopyFrom(const rsa_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rsa_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool rsa_message::IsInitialized() const {
  return true;
}

void rsa_message::InternalSwap(rsa_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &public_modulus_, lhs_arena,
      &other->public_modulus_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &public_exponent_, lhs_arena,
      &other->public_exponent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &private_exponent_, lhs_arena,
      &other->private_exponent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &private_p_, lhs_arena,
      &other->private_p_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &private_q_, lhs_arena,
      &other->private_q_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &private_dp_, lhs_arena,
      &other->private_dp_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &private_dq_, lhs_arena,
      &other->private_dq_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata rsa_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[1]);
}

// ===================================================================

class point_message::_Internal {
 public:
  using HasBits = decltype(std::declval<point_message>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

point_message::point_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:point_message)
}
point_message::point_message(const point_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  x_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    x_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_x()) {
    x_.Set(from._internal_x(), 
      GetArenaForAllocation());
  }
  y_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    y_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_y()) {
    y_.Set(from._internal_y(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:point_message)
}

inline void point_message::SharedCtor() {
x_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  x_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
y_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  y_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

point_message::~point_message() {
  // @@protoc_insertion_point(destructor:point_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void point_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  x_.Destroy();
  y_.Destroy();
}

void point_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void point_message::Clear() {
// @@protoc_insertion_point(message_clear_start:point_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      y_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* point_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_x();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_y();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* point_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:point_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_x(), target);
  }

  // optional bytes y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:point_message)
  return target;
}

size_t point_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:point_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_x());
    }

    // optional bytes y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData point_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    point_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*point_message::GetClassData() const { return &_class_data_; }

void point_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<point_message *>(to)->MergeFrom(
      static_cast<const point_message &>(from));
}


void point_message::MergeFrom(const point_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:point_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_x(from._internal_x());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_y(from._internal_y());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void point_message::CopyFrom(const point_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:point_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool point_message::IsInitialized() const {
  return true;
}

void point_message::InternalSwap(point_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &x_, lhs_arena,
      &other->x_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &y_, lhs_arena,
      &other->y_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata point_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[2]);
}

// ===================================================================

class ecc_message::_Internal {
 public:
  using HasBits = decltype(std::declval<ecc_message>()._has_bits_);
  static void set_has_curve_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_curve_p(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_curve_a(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_curve_b(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::point_message& base_point(const ecc_message* msg);
  static void set_has_base_point(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::point_message& public_point(const ecc_message* msg);
  static void set_has_public_point(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_order_of_base_point(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_private_multiplier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::point_message&
ecc_message::_Internal::base_point(const ecc_message* msg) {
  return *msg->base_point_;
}
const ::point_message&
ecc_message::_Internal::public_point(const ecc_message* msg) {
  return *msg->public_point_;
}
ecc_message::ecc_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ecc_message)
}
ecc_message::ecc_message(const ecc_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  curve_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    curve_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_curve_name()) {
    curve_name_.Set(from._internal_curve_name(), 
      GetArenaForAllocation());
  }
  curve_p_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    curve_p_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_curve_p()) {
    curve_p_.Set(from._internal_curve_p(), 
      GetArenaForAllocation());
  }
  curve_a_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    curve_a_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_curve_a()) {
    curve_a_.Set(from._internal_curve_a(), 
      GetArenaForAllocation());
  }
  curve_b_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    curve_b_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_curve_b()) {
    curve_b_.Set(from._internal_curve_b(), 
      GetArenaForAllocation());
  }
  order_of_base_point_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    order_of_base_point_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_order_of_base_point()) {
    order_of_base_point_.Set(from._internal_order_of_base_point(), 
      GetArenaForAllocation());
  }
  private_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    private_multiplier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_private_multiplier()) {
    private_multiplier_.Set(from._internal_private_multiplier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_base_point()) {
    base_point_ = new ::point_message(*from.base_point_);
  } else {
    base_point_ = nullptr;
  }
  if (from._internal_has_public_point()) {
    public_point_ = new ::point_message(*from.public_point_);
  } else {
    public_point_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ecc_message)
}

inline void ecc_message::SharedCtor() {
curve_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  curve_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
curve_p_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  curve_p_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
curve_a_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  curve_a_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
curve_b_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  curve_b_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
order_of_base_point_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  order_of_base_point_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
private_multiplier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  private_multiplier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&base_point_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&public_point_) -
    reinterpret_cast<char*>(&base_point_)) + sizeof(public_point_));
}

ecc_message::~ecc_message() {
  // @@protoc_insertion_point(destructor:ecc_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ecc_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  curve_name_.Destroy();
  curve_p_.Destroy();
  curve_a_.Destroy();
  curve_b_.Destroy();
  order_of_base_point_.Destroy();
  private_multiplier_.Destroy();
  if (this != internal_default_instance()) delete base_point_;
  if (this != internal_default_instance()) delete public_point_;
}

void ecc_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ecc_message::Clear() {
// @@protoc_insertion_point(message_clear_start:ecc_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      curve_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      curve_p_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      curve_a_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      curve_b_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      order_of_base_point_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      private_multiplier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(base_point_ != nullptr);
      base_point_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(public_point_ != nullptr);
      public_point_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ecc_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string curve_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_curve_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ecc_message.curve_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes curve_p = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_curve_p();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes curve_a = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_curve_a();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes curve_b = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_curve_b();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .point_message base_point = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_base_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .point_message public_point = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes order_of_base_point = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_order_of_base_point();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes private_multiplier = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_private_multiplier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ecc_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ecc_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string curve_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_curve_name().data(), static_cast<int>(this->_internal_curve_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ecc_message.curve_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_curve_name(), target);
  }

  // optional bytes curve_p = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_curve_p(), target);
  }

  // optional bytes curve_a = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_curve_a(), target);
  }

  // optional bytes curve_b = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_curve_b(), target);
  }

  // optional .point_message base_point = 5;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::base_point(this),
        _Internal::base_point(this).GetCachedSize(), target, stream);
  }

  // optional .point_message public_point = 6;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::public_point(this),
        _Internal::public_point(this).GetCachedSize(), target, stream);
  }

  // optional bytes order_of_base_point = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_order_of_base_point(), target);
  }

  // optional bytes private_multiplier = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_private_multiplier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ecc_message)
  return target;
}

size_t ecc_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ecc_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string curve_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_curve_name());
    }

    // optional bytes curve_p = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_curve_p());
    }

    // optional bytes curve_a = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_curve_a());
    }

    // optional bytes curve_b = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_curve_b());
    }

    // optional bytes order_of_base_point = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_order_of_base_point());
    }

    // optional bytes private_multiplier = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_private_multiplier());
    }

    // optional .point_message base_point = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_point_);
    }

    // optional .point_message public_point = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *public_point_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ecc_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ecc_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ecc_message::GetClassData() const { return &_class_data_; }

void ecc_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ecc_message *>(to)->MergeFrom(
      static_cast<const ecc_message &>(from));
}


void ecc_message::MergeFrom(const ecc_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ecc_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_curve_name(from._internal_curve_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_curve_p(from._internal_curve_p());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_curve_a(from._internal_curve_a());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_curve_b(from._internal_curve_b());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_order_of_base_point(from._internal_order_of_base_point());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_private_multiplier(from._internal_private_multiplier());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_base_point()->::point_message::MergeFrom(from._internal_base_point());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_public_point()->::point_message::MergeFrom(from._internal_public_point());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ecc_message::CopyFrom(const ecc_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ecc_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ecc_message::IsInitialized() const {
  return true;
}

void ecc_message::InternalSwap(ecc_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &curve_name_, lhs_arena,
      &other->curve_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &curve_p_, lhs_arena,
      &other->curve_p_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &curve_a_, lhs_arena,
      &other->curve_a_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &curve_b_, lhs_arena,
      &other->curve_b_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &order_of_base_point_, lhs_arena,
      &other->order_of_base_point_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &private_multiplier_, lhs_arena,
      &other->private_multiplier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ecc_message, public_point_)
      + sizeof(ecc_message::public_point_)
      - PROTOBUF_FIELD_OFFSET(ecc_message, base_point_)>(
          reinterpret_cast<char*>(&base_point_),
          reinterpret_cast<char*>(&other->base_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ecc_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[3]);
}

// ===================================================================

class key_message::_Internal {
 public:
  using HasBits = decltype(std::declval<key_message>()._has_bits_);
  static void set_has_key_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::rsa_message& rsa_key(const key_message* msg);
  static void set_has_rsa_key(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::ecc_message& ecc_key(const key_message* msg);
  static void set_has_ecc_key(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_secret_key_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_certificate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_other_key_formats(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_not_before(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_not_after(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::rsa_message&
key_message::_Internal::rsa_key(const key_message* msg) {
  return *msg->rsa_key_;
}
const ::ecc_message&
key_message::_Internal::ecc_key(const key_message* msg) {
  return *msg->ecc_key_;
}
key_message::key_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:key_message)
}
key_message::key_message(const key_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_name()) {
    key_name_.Set(from._internal_key_name(), 
      GetArenaForAllocation());
  }
  key_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_type()) {
    key_type_.Set(from._internal_key_type(), 
      GetArenaForAllocation());
  }
  key_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_format()) {
    key_format_.Set(from._internal_key_format(), 
      GetArenaForAllocation());
  }
  secret_key_bits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    secret_key_bits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secret_key_bits()) {
    secret_key_bits_.Set(from._internal_secret_key_bits(), 
      GetArenaForAllocation());
  }
  certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_certificate()) {
    certificate_.Set(from._internal_certificate(), 
      GetArenaForAllocation());
  }
  other_key_formats_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    other_key_formats_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_other_key_formats()) {
    other_key_formats_.Set(from._internal_other_key_formats(), 
      GetArenaForAllocation());
  }
  not_before_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    not_before_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_before()) {
    not_before_.Set(from._internal_not_before(), 
      GetArenaForAllocation());
  }
  not_after_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    not_after_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_after()) {
    not_after_.Set(from._internal_not_after(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rsa_key()) {
    rsa_key_ = new ::rsa_message(*from.rsa_key_);
  } else {
    rsa_key_ = nullptr;
  }
  if (from._internal_has_ecc_key()) {
    ecc_key_ = new ::ecc_message(*from.ecc_key_);
  } else {
    ecc_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:key_message)
}

inline void key_message::SharedCtor() {
key_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_format_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_format_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
secret_key_bits_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  secret_key_bits_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
certificate_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  certificate_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
other_key_formats_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  other_key_formats_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
not_before_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  not_before_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
not_after_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  not_after_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rsa_key_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ecc_key_) -
    reinterpret_cast<char*>(&rsa_key_)) + sizeof(ecc_key_));
}

key_message::~key_message() {
  // @@protoc_insertion_point(destructor:key_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void key_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_name_.Destroy();
  key_type_.Destroy();
  key_format_.Destroy();
  secret_key_bits_.Destroy();
  certificate_.Destroy();
  other_key_formats_.Destroy();
  not_before_.Destroy();
  not_after_.Destroy();
  if (this != internal_default_instance()) delete rsa_key_;
  if (this != internal_default_instance()) delete ecc_key_;
}

void key_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void key_message::Clear() {
// @@protoc_insertion_point(message_clear_start:key_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      key_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      key_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      key_format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      secret_key_bits_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      certificate_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      other_key_formats_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      not_before_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      not_after_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(rsa_key_ != nullptr);
      rsa_key_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(ecc_key_ != nullptr);
      ecc_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* key_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string key_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "key_message.key_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string key_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "key_message.key_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string key_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_key_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "key_message.key_format");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .rsa_message rsa_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsa_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ecc_message ecc_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ecc_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes secret_key_bits = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_secret_key_bits();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes certificate = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_certificate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes other_key_formats = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_other_key_formats();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string not_before = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_not_before();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "key_message.not_before");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string not_after = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_not_after();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "key_message.not_after");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* key_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:key_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string key_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_name().data(), static_cast<int>(this->_internal_key_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.key_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key_name(), target);
  }

  // optional string key_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_type().data(), static_cast<int>(this->_internal_key_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.key_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key_type(), target);
  }

  // optional string key_format = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key_format().data(), static_cast<int>(this->_internal_key_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.key_format");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_key_format(), target);
  }

  // optional .rsa_message rsa_key = 4;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rsa_key(this),
        _Internal::rsa_key(this).GetCachedSize(), target, stream);
  }

  // optional .ecc_message ecc_key = 5;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::ecc_key(this),
        _Internal::ecc_key(this).GetCachedSize(), target, stream);
  }

  // optional bytes secret_key_bits = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_secret_key_bits(), target);
  }

  // optional bytes certificate = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_certificate(), target);
  }

  // optional bytes other_key_formats = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_other_key_formats(), target);
  }

  // optional string not_before = 9;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_before().data(), static_cast<int>(this->_internal_not_before().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.not_before");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_not_before(), target);
  }

  // optional string not_after = 10;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_after().data(), static_cast<int>(this->_internal_not_after().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "key_message.not_after");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_not_after(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:key_message)
  return target;
}

size_t key_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:key_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string key_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_name());
    }

    // optional string key_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_type());
    }

    // optional string key_format = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key_format());
    }

    // optional bytes secret_key_bits = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_secret_key_bits());
    }

    // optional bytes certificate = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_certificate());
    }

    // optional bytes other_key_formats = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_other_key_formats());
    }

    // optional string not_before = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_before());
    }

    // optional string not_after = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_after());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .rsa_message rsa_key = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rsa_key_);
    }

    // optional .ecc_message ecc_key = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ecc_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData key_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    key_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*key_message::GetClassData() const { return &_class_data_; }

void key_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<key_message *>(to)->MergeFrom(
      static_cast<const key_message &>(from));
}


void key_message::MergeFrom(const key_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:key_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key_name(from._internal_key_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_key_type(from._internal_key_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_key_format(from._internal_key_format());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_secret_key_bits(from._internal_secret_key_bits());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_certificate(from._internal_certificate());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_other_key_formats(from._internal_other_key_formats());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_not_before(from._internal_not_before());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_not_after(from._internal_not_after());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_rsa_key()->::rsa_message::MergeFrom(from._internal_rsa_key());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_ecc_key()->::ecc_message::MergeFrom(from._internal_ecc_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void key_message::CopyFrom(const key_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:key_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool key_message::IsInitialized() const {
  return true;
}

void key_message::InternalSwap(key_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_name_, lhs_arena,
      &other->key_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_type_, lhs_arena,
      &other->key_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_format_, lhs_arena,
      &other->key_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &secret_key_bits_, lhs_arena,
      &other->secret_key_bits_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &certificate_, lhs_arena,
      &other->certificate_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &other_key_formats_, lhs_arena,
      &other->other_key_formats_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &not_before_, lhs_arena,
      &other->not_before_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &not_after_, lhs_arena,
      &other->not_after_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(key_message, ecc_key_)
      + sizeof(key_message::ecc_key_)
      - PROTOBUF_FIELD_OFFSET(key_message, rsa_key_)>(
          reinterpret_cast<char*>(&rsa_key_),
          reinterpret_cast<char*>(&other->rsa_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata key_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[4]);
}

// ===================================================================

class protected_blob_message::_Internal {
 public:
  using HasBits = decltype(std::declval<protected_blob_message>()._has_bits_);
  static void set_has_encrypted_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_encrypted_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

protected_blob_message::protected_blob_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:protected_blob_message)
}
protected_blob_message::protected_blob_message(const protected_blob_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypted_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encrypted_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encrypted_key()) {
    encrypted_key_.Set(from._internal_encrypted_key(), 
      GetArenaForAllocation());
  }
  encrypted_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encrypted_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encrypted_data()) {
    encrypted_data_.Set(from._internal_encrypted_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protected_blob_message)
}

inline void protected_blob_message::SharedCtor() {
encrypted_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encrypted_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
encrypted_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encrypted_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

protected_blob_message::~protected_blob_message() {
  // @@protoc_insertion_point(destructor:protected_blob_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void protected_blob_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypted_key_.Destroy();
  encrypted_data_.Destroy();
}

void protected_blob_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void protected_blob_message::Clear() {
// @@protoc_insertion_point(message_clear_start:protected_blob_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      encrypted_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      encrypted_data_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* protected_blob_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes encrypted_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_encrypted_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes encrypted_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_encrypted_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* protected_blob_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protected_blob_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes encrypted_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_encrypted_key(), target);
  }

  // optional bytes encrypted_data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_encrypted_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protected_blob_message)
  return target;
}

size_t protected_blob_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protected_blob_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes encrypted_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encrypted_key());
    }

    // optional bytes encrypted_data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encrypted_data());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData protected_blob_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    protected_blob_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*protected_blob_message::GetClassData() const { return &_class_data_; }

void protected_blob_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<protected_blob_message *>(to)->MergeFrom(
      static_cast<const protected_blob_message &>(from));
}


void protected_blob_message::MergeFrom(const protected_blob_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protected_blob_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_encrypted_key(from._internal_encrypted_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_encrypted_data(from._internal_encrypted_data());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void protected_blob_message::CopyFrom(const protected_blob_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protected_blob_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool protected_blob_message::IsInitialized() const {
  return true;
}

void protected_blob_message::InternalSwap(protected_blob_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &encrypted_key_, lhs_arena,
      &other->encrypted_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &encrypted_data_, lhs_arena,
      &other->encrypted_data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata protected_blob_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[5]);
}

// ===================================================================

class entity_message::_Internal {
 public:
  using HasBits = decltype(std::declval<entity_message>()._has_bits_);
  static void set_has_entity_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& key(const entity_message* msg);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_measurement(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::key_message&
entity_message::_Internal::key(const entity_message* msg) {
  return *msg->key_;
}
entity_message::entity_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:entity_message)
}
entity_message::entity_message(const entity_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  entity_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    entity_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entity_type()) {
    entity_type_.Set(from._internal_entity_type(), 
      GetArenaForAllocation());
  }
  measurement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    measurement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_measurement()) {
    measurement_.Set(from._internal_measurement(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_key()) {
    key_ = new ::key_message(*from.key_);
  } else {
    key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:entity_message)
}

inline void entity_message::SharedCtor() {
entity_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  entity_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
measurement_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  measurement_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_ = nullptr;
}

entity_message::~entity_message() {
  // @@protoc_insertion_point(destructor:entity_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void entity_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  entity_type_.Destroy();
  measurement_.Destroy();
  if (this != internal_default_instance()) delete key_;
}

void entity_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void entity_message::Clear() {
// @@protoc_insertion_point(message_clear_start:entity_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      entity_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      measurement_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(key_ != nullptr);
      key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* entity_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string entity_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_entity_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "entity_message.entity_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .key_message key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes measurement = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_measurement();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* entity_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:entity_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string entity_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_entity_type().data(), static_cast<int>(this->_internal_entity_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "entity_message.entity_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_entity_type(), target);
  }

  // optional .key_message key = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // optional bytes measurement = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_measurement(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:entity_message)
  return target;
}

size_t entity_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:entity_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string entity_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_entity_type());
    }

    // optional bytes measurement = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_measurement());
    }

    // optional .key_message key = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData entity_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    entity_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*entity_message::GetClassData() const { return &_class_data_; }

void entity_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<entity_message *>(to)->MergeFrom(
      static_cast<const entity_message &>(from));
}


void entity_message::MergeFrom(const entity_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:entity_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_entity_type(from._internal_entity_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_measurement(from._internal_measurement());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_key()->::key_message::MergeFrom(from._internal_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void entity_message::CopyFrom(const entity_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:entity_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool entity_message::IsInitialized() const {
  return true;
}

void entity_message::InternalSwap(entity_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &entity_type_, lhs_arena,
      &other->entity_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &measurement_, lhs_arena,
      &other->measurement_, rhs_arena
  );
  swap(key_, other->key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata entity_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[6]);
}

// ===================================================================

class vse_clause::_Internal {
 public:
  using HasBits = decltype(std::declval<vse_clause>()._has_bits_);
  static const ::entity_message& subject(const vse_clause* msg);
  static void set_has_subject(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_verb(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::entity_message& object(const vse_clause* msg);
  static void set_has_object(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::vse_clause& clause(const vse_clause* msg);
  static void set_has_clause(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::entity_message&
vse_clause::_Internal::subject(const vse_clause* msg) {
  return *msg->subject_;
}
const ::entity_message&
vse_clause::_Internal::object(const vse_clause* msg) {
  return *msg->object_;
}
const ::vse_clause&
vse_clause::_Internal::clause(const vse_clause* msg) {
  return *msg->clause_;
}
vse_clause::vse_clause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:vse_clause)
}
vse_clause::vse_clause(const vse_clause& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  verb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    verb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_verb()) {
    verb_.Set(from._internal_verb(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_subject()) {
    subject_ = new ::entity_message(*from.subject_);
  } else {
    subject_ = nullptr;
  }
  if (from._internal_has_object()) {
    object_ = new ::entity_message(*from.object_);
  } else {
    object_ = nullptr;
  }
  if (from._internal_has_clause()) {
    clause_ = new ::vse_clause(*from.clause_);
  } else {
    clause_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:vse_clause)
}

inline void vse_clause::SharedCtor() {
verb_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  verb_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&subject_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&clause_) -
    reinterpret_cast<char*>(&subject_)) + sizeof(clause_));
}

vse_clause::~vse_clause() {
  // @@protoc_insertion_point(destructor:vse_clause)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void vse_clause::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  verb_.Destroy();
  if (this != internal_default_instance()) delete subject_;
  if (this != internal_default_instance()) delete object_;
  if (this != internal_default_instance()) delete clause_;
}

void vse_clause::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void vse_clause::Clear() {
// @@protoc_insertion_point(message_clear_start:vse_clause)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      verb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(subject_ != nullptr);
      subject_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(object_ != nullptr);
      object_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(clause_ != nullptr);
      clause_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* vse_clause::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .entity_message subject = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subject(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string verb = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_verb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "vse_clause.verb");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .entity_message object = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause clause = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_clause(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vse_clause::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vse_clause)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .entity_message subject = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::subject(this),
        _Internal::subject(this).GetCachedSize(), target, stream);
  }

  // optional string verb = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_verb().data(), static_cast<int>(this->_internal_verb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "vse_clause.verb");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_verb(), target);
  }

  // optional .entity_message object = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::object(this),
        _Internal::object(this).GetCachedSize(), target, stream);
  }

  // optional .vse_clause clause = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::clause(this),
        _Internal::clause(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vse_clause)
  return target;
}

size_t vse_clause::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vse_clause)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string verb = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_verb());
    }

    // optional .entity_message subject = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *subject_);
    }

    // optional .entity_message object = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_);
    }

    // optional .vse_clause clause = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *clause_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData vse_clause::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    vse_clause::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*vse_clause::GetClassData() const { return &_class_data_; }

void vse_clause::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<vse_clause *>(to)->MergeFrom(
      static_cast<const vse_clause &>(from));
}


void vse_clause::MergeFrom(const vse_clause& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vse_clause)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_verb(from._internal_verb());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_subject()->::entity_message::MergeFrom(from._internal_subject());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_object()->::entity_message::MergeFrom(from._internal_object());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_clause()->::vse_clause::MergeFrom(from._internal_clause());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void vse_clause::CopyFrom(const vse_clause& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vse_clause)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vse_clause::IsInitialized() const {
  return true;
}

void vse_clause::InternalSwap(vse_clause* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &verb_, lhs_arena,
      &other->verb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(vse_clause, clause_)
      + sizeof(vse_clause::clause_)
      - PROTOBUF_FIELD_OFFSET(vse_clause, subject_)>(
          reinterpret_cast<char*>(&subject_),
          reinterpret_cast<char*>(&other->subject_));
}

::PROTOBUF_NAMESPACE_ID::Metadata vse_clause::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[7]);
}

// ===================================================================

class vse_clauses::_Internal {
 public:
};

vse_clauses::vse_clauses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  clauses_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:vse_clauses)
}
vse_clauses::vse_clauses(const vse_clauses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      clauses_(from.clauses_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vse_clauses)
}

inline void vse_clauses::SharedCtor() {
}

vse_clauses::~vse_clauses() {
  // @@protoc_insertion_point(destructor:vse_clauses)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void vse_clauses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void vse_clauses::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void vse_clauses::Clear() {
// @@protoc_insertion_point(message_clear_start:vse_clauses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clauses_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* vse_clauses::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vse_clause clauses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_clauses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vse_clauses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vse_clauses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vse_clause clauses = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_clauses_size()); i < n; i++) {
    const auto& repfield = this->_internal_clauses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vse_clauses)
  return target;
}

size_t vse_clauses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vse_clauses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vse_clause clauses = 1;
  total_size += 1UL * this->_internal_clauses_size();
  for (const auto& msg : this->clauses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData vse_clauses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    vse_clauses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*vse_clauses::GetClassData() const { return &_class_data_; }

void vse_clauses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<vse_clauses *>(to)->MergeFrom(
      static_cast<const vse_clauses &>(from));
}


void vse_clauses::MergeFrom(const vse_clauses& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vse_clauses)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  clauses_.MergeFrom(from.clauses_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void vse_clauses::CopyFrom(const vse_clauses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vse_clauses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vse_clauses::IsInitialized() const {
  return true;
}

void vse_clauses::InternalSwap(vse_clauses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  clauses_.InternalSwap(&other->clauses_);
}

::PROTOBUF_NAMESPACE_ID::Metadata vse_clauses::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[8]);
}

// ===================================================================

class claim_message::_Internal {
 public:
  using HasBits = decltype(std::declval<claim_message>()._has_bits_);
  static void set_has_claim_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_claim_descriptor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_not_before(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_not_after(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_serialized_claim(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

claim_message::claim_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:claim_message)
}
claim_message::claim_message(const claim_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  claim_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    claim_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_claim_format()) {
    claim_format_.Set(from._internal_claim_format(), 
      GetArenaForAllocation());
  }
  claim_descriptor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    claim_descriptor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_claim_descriptor()) {
    claim_descriptor_.Set(from._internal_claim_descriptor(), 
      GetArenaForAllocation());
  }
  not_before_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    not_before_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_before()) {
    not_before_.Set(from._internal_not_before(), 
      GetArenaForAllocation());
  }
  not_after_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    not_after_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_after()) {
    not_after_.Set(from._internal_not_after(), 
      GetArenaForAllocation());
  }
  serialized_claim_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serialized_claim_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_claim()) {
    serialized_claim_.Set(from._internal_serialized_claim(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:claim_message)
}

inline void claim_message::SharedCtor() {
claim_format_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  claim_format_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
claim_descriptor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  claim_descriptor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
not_before_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  not_before_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
not_after_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  not_after_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
serialized_claim_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serialized_claim_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

claim_message::~claim_message() {
  // @@protoc_insertion_point(destructor:claim_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void claim_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  claim_format_.Destroy();
  claim_descriptor_.Destroy();
  not_before_.Destroy();
  not_after_.Destroy();
  serialized_claim_.Destroy();
}

void claim_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void claim_message::Clear() {
// @@protoc_insertion_point(message_clear_start:claim_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      claim_format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      claim_descriptor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      not_before_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      not_after_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      serialized_claim_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* claim_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string claim_format = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_claim_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "claim_message.claim_format");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string claim_descriptor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_claim_descriptor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "claim_message.claim_descriptor");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string not_before = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_not_before();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "claim_message.not_before");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string not_after = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_not_after();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "claim_message.not_after");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes serialized_claim = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_serialized_claim();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* claim_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:claim_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string claim_format = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_claim_format().data(), static_cast<int>(this->_internal_claim_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.claim_format");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_claim_format(), target);
  }

  // optional string claim_descriptor = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_claim_descriptor().data(), static_cast<int>(this->_internal_claim_descriptor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.claim_descriptor");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_claim_descriptor(), target);
  }

  // optional string not_before = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_before().data(), static_cast<int>(this->_internal_not_before().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.not_before");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_not_before(), target);
  }

  // optional string not_after = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_after().data(), static_cast<int>(this->_internal_not_after().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "claim_message.not_after");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_not_after(), target);
  }

  // optional bytes serialized_claim = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_serialized_claim(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:claim_message)
  return target;
}

size_t claim_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:claim_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string claim_format = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_claim_format());
    }

    // optional string claim_descriptor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_claim_descriptor());
    }

    // optional string not_before = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_before());
    }

    // optional string not_after = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_after());
    }

    // optional bytes serialized_claim = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_claim());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData claim_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    claim_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*claim_message::GetClassData() const { return &_class_data_; }

void claim_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<claim_message *>(to)->MergeFrom(
      static_cast<const claim_message &>(from));
}


void claim_message::MergeFrom(const claim_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:claim_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_claim_format(from._internal_claim_format());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_claim_descriptor(from._internal_claim_descriptor());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_not_before(from._internal_not_before());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_not_after(from._internal_not_after());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_serialized_claim(from._internal_serialized_claim());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void claim_message::CopyFrom(const claim_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:claim_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool claim_message::IsInitialized() const {
  return true;
}

void claim_message::InternalSwap(claim_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &claim_format_, lhs_arena,
      &other->claim_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &claim_descriptor_, lhs_arena,
      &other->claim_descriptor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &not_before_, lhs_arena,
      &other->not_before_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &not_after_, lhs_arena,
      &other->not_after_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &serialized_claim_, lhs_arena,
      &other->serialized_claim_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata claim_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[9]);
}

// ===================================================================

class attestation_user_data::_Internal {
 public:
  using HasBits = decltype(std::declval<attestation_user_data>()._has_bits_);
  static void set_has_enclave_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::key_message& enclave_key(const attestation_user_data* msg);
  static void set_has_enclave_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::key_message& policy_key(const attestation_user_data* msg);
  static void set_has_policy_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::key_message&
attestation_user_data::_Internal::enclave_key(const attestation_user_data* msg) {
  return *msg->enclave_key_;
}
const ::key_message&
attestation_user_data::_Internal::policy_key(const attestation_user_data* msg) {
  return *msg->policy_key_;
}
attestation_user_data::attestation_user_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:attestation_user_data)
}
attestation_user_data::attestation_user_data(const attestation_user_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  enclave_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    enclave_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_enclave_type()) {
    enclave_type_.Set(from._internal_enclave_type(), 
      GetArenaForAllocation());
  }
  time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_time()) {
    time_.Set(from._internal_time(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_enclave_key()) {
    enclave_key_ = new ::key_message(*from.enclave_key_);
  } else {
    enclave_key_ = nullptr;
  }
  if (from._internal_has_policy_key()) {
    policy_key_ = new ::key_message(*from.policy_key_);
  } else {
    policy_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:attestation_user_data)
}

inline void attestation_user_data::SharedCtor() {
enclave_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  enclave_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
time_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  time_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&enclave_key_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&policy_key_) -
    reinterpret_cast<char*>(&enclave_key_)) + sizeof(policy_key_));
}

attestation_user_data::~attestation_user_data() {
  // @@protoc_insertion_point(destructor:attestation_user_data)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void attestation_user_data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  enclave_type_.Destroy();
  time_.Destroy();
  if (this != internal_default_instance()) delete enclave_key_;
  if (this != internal_default_instance()) delete policy_key_;
}

void attestation_user_data::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void attestation_user_data::Clear() {
// @@protoc_insertion_point(message_clear_start:attestation_user_data)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      enclave_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(enclave_key_ != nullptr);
      enclave_key_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(policy_key_ != nullptr);
      policy_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* attestation_user_data::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string enclave_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_enclave_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "attestation_user_data.enclave_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "attestation_user_data.time");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .key_message enclave_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_enclave_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .key_message policy_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_policy_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* attestation_user_data::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:attestation_user_data)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string enclave_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_enclave_type().data(), static_cast<int>(this->_internal_enclave_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "attestation_user_data.enclave_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_enclave_type(), target);
  }

  // optional string time = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_time().data(), static_cast<int>(this->_internal_time().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "attestation_user_data.time");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_time(), target);
  }

  // optional .key_message enclave_key = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::enclave_key(this),
        _Internal::enclave_key(this).GetCachedSize(), target, stream);
  }

  // optional .key_message policy_key = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::policy_key(this),
        _Internal::policy_key(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:attestation_user_data)
  return target;
}

size_t attestation_user_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:attestation_user_data)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string enclave_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_enclave_type());
    }

    // optional string time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_time());
    }

    // optional .key_message enclave_key = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *enclave_key_);
    }

    // optional .key_message policy_key = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *policy_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData attestation_user_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    attestation_user_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*attestation_user_data::GetClassData() const { return &_class_data_; }

void attestation_user_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<attestation_user_data *>(to)->MergeFrom(
      static_cast<const attestation_user_data &>(from));
}


void attestation_user_data::MergeFrom(const attestation_user_data& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:attestation_user_data)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_enclave_type(from._internal_enclave_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_time(from._internal_time());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_enclave_key()->::key_message::MergeFrom(from._internal_enclave_key());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_policy_key()->::key_message::MergeFrom(from._internal_policy_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void attestation_user_data::CopyFrom(const attestation_user_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:attestation_user_data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool attestation_user_data::IsInitialized() const {
  return true;
}

void attestation_user_data::InternalSwap(attestation_user_data* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &enclave_type_, lhs_arena,
      &other->enclave_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &time_, lhs_arena,
      &other->time_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(attestation_user_data, policy_key_)
      + sizeof(attestation_user_data::policy_key_)
      - PROTOBUF_FIELD_OFFSET(attestation_user_data, enclave_key_)>(
          reinterpret_cast<char*>(&enclave_key_),
          reinterpret_cast<char*>(&other->enclave_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata attestation_user_data::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[10]);
}

// ===================================================================

class vse_attestation_report_info::_Internal {
 public:
  using HasBits = decltype(std::declval<vse_attestation_report_info>()._has_bits_);
  static void set_has_enclave_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_verified_measurement(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_not_before(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_not_after(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_data(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

vse_attestation_report_info::vse_attestation_report_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:vse_attestation_report_info)
}
vse_attestation_report_info::vse_attestation_report_info(const vse_attestation_report_info& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  enclave_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    enclave_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_enclave_type()) {
    enclave_type_.Set(from._internal_enclave_type(), 
      GetArenaForAllocation());
  }
  verified_measurement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    verified_measurement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_verified_measurement()) {
    verified_measurement_.Set(from._internal_verified_measurement(), 
      GetArenaForAllocation());
  }
  not_before_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    not_before_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_before()) {
    not_before_.Set(from._internal_not_before(), 
      GetArenaForAllocation());
  }
  not_after_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    not_after_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_after()) {
    not_after_.Set(from._internal_not_after(), 
      GetArenaForAllocation());
  }
  user_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_data()) {
    user_data_.Set(from._internal_user_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vse_attestation_report_info)
}

inline void vse_attestation_report_info::SharedCtor() {
enclave_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  enclave_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
verified_measurement_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  verified_measurement_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
not_before_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  not_before_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
not_after_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  not_after_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

vse_attestation_report_info::~vse_attestation_report_info() {
  // @@protoc_insertion_point(destructor:vse_attestation_report_info)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void vse_attestation_report_info::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  enclave_type_.Destroy();
  verified_measurement_.Destroy();
  not_before_.Destroy();
  not_after_.Destroy();
  user_data_.Destroy();
}

void vse_attestation_report_info::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void vse_attestation_report_info::Clear() {
// @@protoc_insertion_point(message_clear_start:vse_attestation_report_info)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      enclave_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      verified_measurement_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      not_before_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      not_after_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      user_data_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* vse_attestation_report_info::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string enclave_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_enclave_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "vse_attestation_report_info.enclave_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes verified_measurement = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_verified_measurement();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string not_before = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_not_before();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "vse_attestation_report_info.not_before");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string not_after = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_not_after();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "vse_attestation_report_info.not_after");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes user_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_user_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vse_attestation_report_info::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vse_attestation_report_info)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string enclave_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_enclave_type().data(), static_cast<int>(this->_internal_enclave_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "vse_attestation_report_info.enclave_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_enclave_type(), target);
  }

  // optional bytes verified_measurement = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_verified_measurement(), target);
  }

  // optional string not_before = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_before().data(), static_cast<int>(this->_internal_not_before().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "vse_attestation_report_info.not_before");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_not_before(), target);
  }

  // optional string not_after = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_after().data(), static_cast<int>(this->_internal_not_after().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "vse_attestation_report_info.not_after");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_not_after(), target);
  }

  // optional bytes user_data = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_user_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vse_attestation_report_info)
  return target;
}

size_t vse_attestation_report_info::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vse_attestation_report_info)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string enclave_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_enclave_type());
    }

    // optional bytes verified_measurement = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_verified_measurement());
    }

    // optional string not_before = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_before());
    }

    // optional string not_after = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_after());
    }

    // optional bytes user_data = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user_data());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData vse_attestation_report_info::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    vse_attestation_report_info::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*vse_attestation_report_info::GetClassData() const { return &_class_data_; }

void vse_attestation_report_info::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<vse_attestation_report_info *>(to)->MergeFrom(
      static_cast<const vse_attestation_report_info &>(from));
}


void vse_attestation_report_info::MergeFrom(const vse_attestation_report_info& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vse_attestation_report_info)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_enclave_type(from._internal_enclave_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_verified_measurement(from._internal_verified_measurement());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_not_before(from._internal_not_before());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_not_after(from._internal_not_after());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_user_data(from._internal_user_data());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void vse_attestation_report_info::CopyFrom(const vse_attestation_report_info& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vse_attestation_report_info)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vse_attestation_report_info::IsInitialized() const {
  return true;
}

void vse_attestation_report_info::InternalSwap(vse_attestation_report_info* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &enclave_type_, lhs_arena,
      &other->enclave_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &verified_measurement_, lhs_arena,
      &other->verified_measurement_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &not_before_, lhs_arena,
      &other->not_before_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &not_after_, lhs_arena,
      &other->not_after_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_data_, lhs_arena,
      &other->user_data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata vse_attestation_report_info::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[11]);
}

// ===================================================================

class signed_report::_Internal {
 public:
  using HasBits = decltype(std::declval<signed_report>()._has_bits_);
  static void set_has_report_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_report(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::key_message& signing_key(const signed_report* msg);
  static void set_has_signing_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_signing_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::key_message&
signed_report::_Internal::signing_key(const signed_report* msg) {
  return *msg->signing_key_;
}
signed_report::signed_report(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:signed_report)
}
signed_report::signed_report(const signed_report& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  report_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    report_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_report_format()) {
    report_format_.Set(from._internal_report_format(), 
      GetArenaForAllocation());
  }
  report_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    report_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_report()) {
    report_.Set(from._internal_report(), 
      GetArenaForAllocation());
  }
  signing_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signing_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signing_algorithm()) {
    signing_algorithm_.Set(from._internal_signing_algorithm(), 
      GetArenaForAllocation());
  }
  signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    signature_.Set(from._internal_signature(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_signing_key()) {
    signing_key_ = new ::key_message(*from.signing_key_);
  } else {
    signing_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:signed_report)
}

inline void signed_report::SharedCtor() {
report_format_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  report_format_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
report_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  report_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signing_algorithm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signing_algorithm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signature_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signature_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signing_key_ = nullptr;
}

signed_report::~signed_report() {
  // @@protoc_insertion_point(destructor:signed_report)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void signed_report::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  report_format_.Destroy();
  report_.Destroy();
  signing_algorithm_.Destroy();
  signature_.Destroy();
  if (this != internal_default_instance()) delete signing_key_;
}

void signed_report::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void signed_report::Clear() {
// @@protoc_insertion_point(message_clear_start:signed_report)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      report_format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      report_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      signing_algorithm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(signing_key_ != nullptr);
      signing_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* signed_report::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string report_format = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_report_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "signed_report.report_format");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes report = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_report();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .key_message signing_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_signing_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string signing_algorithm = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_signing_algorithm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "signed_report.signing_algorithm");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* signed_report::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signed_report)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string report_format = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_report_format().data(), static_cast<int>(this->_internal_report_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "signed_report.report_format");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_report_format(), target);
  }

  // optional bytes report = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_report(), target);
  }

  // optional .key_message signing_key = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::signing_key(this),
        _Internal::signing_key(this).GetCachedSize(), target, stream);
  }

  // optional string signing_algorithm = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_signing_algorithm().data(), static_cast<int>(this->_internal_signing_algorithm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "signed_report.signing_algorithm");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_signing_algorithm(), target);
  }

  // optional bytes signature = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signed_report)
  return target;
}

size_t signed_report::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signed_report)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string report_format = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_report_format());
    }

    // optional bytes report = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_report());
    }

    // optional string signing_algorithm = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signing_algorithm());
    }

    // optional bytes signature = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional .key_message signing_key = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *signing_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData signed_report::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    signed_report::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*signed_report::GetClassData() const { return &_class_data_; }

void signed_report::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<signed_report *>(to)->MergeFrom(
      static_cast<const signed_report &>(from));
}


void signed_report::MergeFrom(const signed_report& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signed_report)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_report_format(from._internal_report_format());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_report(from._internal_report());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_signing_algorithm(from._internal_signing_algorithm());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_signing_key()->::key_message::MergeFrom(from._internal_signing_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void signed_report::CopyFrom(const signed_report& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signed_report)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool signed_report::IsInitialized() const {
  return true;
}

void signed_report::InternalSwap(signed_report* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &report_format_, lhs_arena,
      &other->report_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &report_, lhs_arena,
      &other->report_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &signing_algorithm_, lhs_arena,
      &other->signing_algorithm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  swap(signing_key_, other->signing_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata signed_report::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[12]);
}

// ===================================================================

class signed_claim_message::_Internal {
 public:
  using HasBits = decltype(std::declval<signed_claim_message>()._has_bits_);
  static void set_has_serialized_claim_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& signing_key(const signed_claim_message* msg);
  static void set_has_signing_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_signing_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::key_message&
signed_claim_message::_Internal::signing_key(const signed_claim_message* msg) {
  return *msg->signing_key_;
}
signed_claim_message::signed_claim_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:signed_claim_message)
}
signed_claim_message::signed_claim_message(const signed_claim_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  serialized_claim_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serialized_claim_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_claim_message()) {
    serialized_claim_message_.Set(from._internal_serialized_claim_message(), 
      GetArenaForAllocation());
  }
  signing_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signing_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signing_algorithm()) {
    signing_algorithm_.Set(from._internal_signing_algorithm(), 
      GetArenaForAllocation());
  }
  signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    signature_.Set(from._internal_signature(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_signing_key()) {
    signing_key_ = new ::key_message(*from.signing_key_);
  } else {
    signing_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:signed_claim_message)
}

inline void signed_claim_message::SharedCtor() {
serialized_claim_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serialized_claim_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signing_algorithm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signing_algorithm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signature_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signature_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signing_key_ = nullptr;
}

signed_claim_message::~signed_claim_message() {
  // @@protoc_insertion_point(destructor:signed_claim_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void signed_claim_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  serialized_claim_message_.Destroy();
  signing_algorithm_.Destroy();
  signature_.Destroy();
  if (this != internal_default_instance()) delete signing_key_;
}

void signed_claim_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void signed_claim_message::Clear() {
// @@protoc_insertion_point(message_clear_start:signed_claim_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      serialized_claim_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      signing_algorithm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(signing_key_ != nullptr);
      signing_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* signed_claim_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes serialized_claim_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serialized_claim_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .key_message signing_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_signing_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string signing_algorithm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_signing_algorithm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "signed_claim_message.signing_algorithm");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* signed_claim_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signed_claim_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes serialized_claim_message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_serialized_claim_message(), target);
  }

  // optional .key_message signing_key = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::signing_key(this),
        _Internal::signing_key(this).GetCachedSize(), target, stream);
  }

  // optional string signing_algorithm = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_signing_algorithm().data(), static_cast<int>(this->_internal_signing_algorithm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "signed_claim_message.signing_algorithm");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_signing_algorithm(), target);
  }

  // optional bytes signature = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signed_claim_message)
  return target;
}

size_t signed_claim_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signed_claim_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes serialized_claim_message = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_claim_message());
    }

    // optional string signing_algorithm = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signing_algorithm());
    }

    // optional bytes signature = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional .key_message signing_key = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *signing_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData signed_claim_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    signed_claim_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*signed_claim_message::GetClassData() const { return &_class_data_; }

void signed_claim_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<signed_claim_message *>(to)->MergeFrom(
      static_cast<const signed_claim_message &>(from));
}


void signed_claim_message::MergeFrom(const signed_claim_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signed_claim_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_serialized_claim_message(from._internal_serialized_claim_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_signing_algorithm(from._internal_signing_algorithm());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_signing_key()->::key_message::MergeFrom(from._internal_signing_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void signed_claim_message::CopyFrom(const signed_claim_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signed_claim_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool signed_claim_message::IsInitialized() const {
  return true;
}

void signed_claim_message::InternalSwap(signed_claim_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &serialized_claim_message_, lhs_arena,
      &other->serialized_claim_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &signing_algorithm_, lhs_arena,
      &other->signing_algorithm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  swap(signing_key_, other->signing_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata signed_claim_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[13]);
}

// ===================================================================

class evidence::_Internal {
 public:
  using HasBits = decltype(std::declval<evidence>()._has_bits_);
  static void set_has_evidence_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_serialized_evidence(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

evidence::evidence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:evidence)
}
evidence::evidence(const evidence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  evidence_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    evidence_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_evidence_type()) {
    evidence_type_.Set(from._internal_evidence_type(), 
      GetArenaForAllocation());
  }
  serialized_evidence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serialized_evidence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_evidence()) {
    serialized_evidence_.Set(from._internal_serialized_evidence(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:evidence)
}

inline void evidence::SharedCtor() {
evidence_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  evidence_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
serialized_evidence_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serialized_evidence_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

evidence::~evidence() {
  // @@protoc_insertion_point(destructor:evidence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void evidence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  evidence_type_.Destroy();
  serialized_evidence_.Destroy();
}

void evidence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void evidence::Clear() {
// @@protoc_insertion_point(message_clear_start:evidence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      evidence_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      serialized_evidence_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* evidence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string evidence_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_evidence_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "evidence.evidence_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes serialized_evidence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_serialized_evidence();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* evidence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:evidence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string evidence_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_evidence_type().data(), static_cast<int>(this->_internal_evidence_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "evidence.evidence_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_evidence_type(), target);
  }

  // optional bytes serialized_evidence = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_serialized_evidence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:evidence)
  return target;
}

size_t evidence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:evidence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string evidence_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_evidence_type());
    }

    // optional bytes serialized_evidence = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_evidence());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData evidence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    evidence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*evidence::GetClassData() const { return &_class_data_; }

void evidence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<evidence *>(to)->MergeFrom(
      static_cast<const evidence &>(from));
}


void evidence::MergeFrom(const evidence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:evidence)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_evidence_type(from._internal_evidence_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_serialized_evidence(from._internal_serialized_evidence());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void evidence::CopyFrom(const evidence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:evidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool evidence::IsInitialized() const {
  return true;
}

void evidence::InternalSwap(evidence* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &evidence_type_, lhs_arena,
      &other->evidence_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &serialized_evidence_, lhs_arena,
      &other->serialized_evidence_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata evidence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[14]);
}

// ===================================================================

class evidence_list::_Internal {
 public:
};

evidence_list::evidence_list(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  assertion_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:evidence_list)
}
evidence_list::evidence_list(const evidence_list& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      assertion_(from.assertion_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:evidence_list)
}

inline void evidence_list::SharedCtor() {
}

evidence_list::~evidence_list() {
  // @@protoc_insertion_point(destructor:evidence_list)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void evidence_list::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void evidence_list::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void evidence_list::Clear() {
// @@protoc_insertion_point(message_clear_start:evidence_list)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  assertion_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* evidence_list::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .evidence assertion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_assertion(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* evidence_list::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:evidence_list)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .evidence assertion = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_assertion_size()); i < n; i++) {
    const auto& repfield = this->_internal_assertion(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:evidence_list)
  return target;
}

size_t evidence_list::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:evidence_list)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .evidence assertion = 1;
  total_size += 1UL * this->_internal_assertion_size();
  for (const auto& msg : this->assertion_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData evidence_list::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    evidence_list::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*evidence_list::GetClassData() const { return &_class_data_; }

void evidence_list::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<evidence_list *>(to)->MergeFrom(
      static_cast<const evidence_list &>(from));
}


void evidence_list::MergeFrom(const evidence_list& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:evidence_list)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  assertion_.MergeFrom(from.assertion_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void evidence_list::CopyFrom(const evidence_list& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:evidence_list)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool evidence_list::IsInitialized() const {
  return true;
}

void evidence_list::InternalSwap(evidence_list* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  assertion_.InternalSwap(&other->assertion_);
}

::PROTOBUF_NAMESPACE_ID::Metadata evidence_list::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[15]);
}

// ===================================================================

class sev_attestation_message::_Internal {
 public:
  using HasBits = decltype(std::declval<sev_attestation_message>()._has_bits_);
  static void set_has_what_was_said(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reported_attestation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

sev_attestation_message::sev_attestation_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sev_attestation_message)
}
sev_attestation_message::sev_attestation_message(const sev_attestation_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  what_was_said_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    what_was_said_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_what_was_said()) {
    what_was_said_.Set(from._internal_what_was_said(), 
      GetArenaForAllocation());
  }
  reported_attestation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    reported_attestation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reported_attestation()) {
    reported_attestation_.Set(from._internal_reported_attestation(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sev_attestation_message)
}

inline void sev_attestation_message::SharedCtor() {
what_was_said_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  what_was_said_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
reported_attestation_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  reported_attestation_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

sev_attestation_message::~sev_attestation_message() {
  // @@protoc_insertion_point(destructor:sev_attestation_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void sev_attestation_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  what_was_said_.Destroy();
  reported_attestation_.Destroy();
}

void sev_attestation_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void sev_attestation_message::Clear() {
// @@protoc_insertion_point(message_clear_start:sev_attestation_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      what_was_said_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      reported_attestation_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* sev_attestation_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes what_was_said = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_what_was_said();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reported_attestation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_reported_attestation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* sev_attestation_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sev_attestation_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes what_was_said = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_what_was_said(), target);
  }

  // optional bytes reported_attestation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_reported_attestation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sev_attestation_message)
  return target;
}

size_t sev_attestation_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sev_attestation_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes what_was_said = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_what_was_said());
    }

    // optional bytes reported_attestation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reported_attestation());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData sev_attestation_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    sev_attestation_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*sev_attestation_message::GetClassData() const { return &_class_data_; }

void sev_attestation_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<sev_attestation_message *>(to)->MergeFrom(
      static_cast<const sev_attestation_message &>(from));
}


void sev_attestation_message::MergeFrom(const sev_attestation_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sev_attestation_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_what_was_said(from._internal_what_was_said());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_reported_attestation(from._internal_reported_attestation());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void sev_attestation_message::CopyFrom(const sev_attestation_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sev_attestation_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool sev_attestation_message::IsInitialized() const {
  return true;
}

void sev_attestation_message::InternalSwap(sev_attestation_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &what_was_said_, lhs_arena,
      &other->what_was_said_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &reported_attestation_, lhs_arena,
      &other->reported_attestation_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata sev_attestation_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[16]);
}

// ===================================================================

class evidence_package::_Internal {
 public:
  using HasBits = decltype(std::declval<evidence_package>()._has_bits_);
  static void set_has_prover_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

evidence_package::evidence_package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  fact_assertion_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:evidence_package)
}
evidence_package::evidence_package(const evidence_package& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      fact_assertion_(from.fact_assertion_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  prover_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    prover_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_prover_type()) {
    prover_type_.Set(from._internal_prover_type(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:evidence_package)
}

inline void evidence_package::SharedCtor() {
prover_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  prover_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

evidence_package::~evidence_package() {
  // @@protoc_insertion_point(destructor:evidence_package)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void evidence_package::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  prover_type_.Destroy();
}

void evidence_package::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void evidence_package::Clear() {
// @@protoc_insertion_point(message_clear_start:evidence_package)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fact_assertion_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    prover_type_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* evidence_package::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string prover_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_prover_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "evidence_package.prover_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .evidence fact_assertion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fact_assertion(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* evidence_package::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:evidence_package)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string prover_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_prover_type().data(), static_cast<int>(this->_internal_prover_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "evidence_package.prover_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_prover_type(), target);
  }

  // repeated .evidence fact_assertion = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fact_assertion_size()); i < n; i++) {
    const auto& repfield = this->_internal_fact_assertion(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:evidence_package)
  return target;
}

size_t evidence_package::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:evidence_package)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .evidence fact_assertion = 2;
  total_size += 1UL * this->_internal_fact_assertion_size();
  for (const auto& msg : this->fact_assertion_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string prover_type = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_prover_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData evidence_package::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    evidence_package::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*evidence_package::GetClassData() const { return &_class_data_; }

void evidence_package::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<evidence_package *>(to)->MergeFrom(
      static_cast<const evidence_package &>(from));
}


void evidence_package::MergeFrom(const evidence_package& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:evidence_package)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  fact_assertion_.MergeFrom(from.fact_assertion_);
  if (from._internal_has_prover_type()) {
    _internal_set_prover_type(from._internal_prover_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void evidence_package::CopyFrom(const evidence_package& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:evidence_package)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool evidence_package::IsInitialized() const {
  return true;
}

void evidence_package::InternalSwap(evidence_package* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fact_assertion_.InternalSwap(&other->fact_assertion_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &prover_type_, lhs_arena,
      &other->prover_type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata evidence_package::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[17]);
}

// ===================================================================

class certifier_rules::_Internal {
 public:
};

certifier_rules::certifier_rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  rule_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:certifier_rules)
}
certifier_rules::certifier_rules(const certifier_rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      rule_(from.rule_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:certifier_rules)
}

inline void certifier_rules::SharedCtor() {
}

certifier_rules::~certifier_rules() {
  // @@protoc_insertion_point(destructor:certifier_rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void certifier_rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void certifier_rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void certifier_rules::Clear() {
// @@protoc_insertion_point(message_clear_start:certifier_rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  rule_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* certifier_rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string rule = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_rule();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "certifier_rules.rule");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* certifier_rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:certifier_rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string rule = 1;
  for (int i = 0, n = this->_internal_rule_size(); i < n; i++) {
    const auto& s = this->_internal_rule(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "certifier_rules.rule");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:certifier_rules)
  return target;
}

size_t certifier_rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:certifier_rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string rule = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(rule_.size());
  for (int i = 0, n = rule_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      rule_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData certifier_rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    certifier_rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*certifier_rules::GetClassData() const { return &_class_data_; }

void certifier_rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<certifier_rules *>(to)->MergeFrom(
      static_cast<const certifier_rules &>(from));
}


void certifier_rules::MergeFrom(const certifier_rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:certifier_rules)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  rule_.MergeFrom(from.rule_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void certifier_rules::CopyFrom(const certifier_rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:certifier_rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool certifier_rules::IsInitialized() const {
  return true;
}

void certifier_rules::InternalSwap(certifier_rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  rule_.InternalSwap(&other->rule_);
}

::PROTOBUF_NAMESPACE_ID::Metadata certifier_rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[18]);
}

// ===================================================================

class proved_statements::_Internal {
 public:
};

proved_statements::proved_statements(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  proved_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:proved_statements)
}
proved_statements::proved_statements(const proved_statements& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      proved_(from.proved_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proved_statements)
}

inline void proved_statements::SharedCtor() {
}

proved_statements::~proved_statements() {
  // @@protoc_insertion_point(destructor:proved_statements)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void proved_statements::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void proved_statements::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void proved_statements::Clear() {
// @@protoc_insertion_point(message_clear_start:proved_statements)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  proved_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* proved_statements::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vse_clause proved = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_proved(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* proved_statements::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proved_statements)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vse_clause proved = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_proved_size()); i < n; i++) {
    const auto& repfield = this->_internal_proved(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proved_statements)
  return target;
}

size_t proved_statements::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proved_statements)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vse_clause proved = 1;
  total_size += 1UL * this->_internal_proved_size();
  for (const auto& msg : this->proved_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData proved_statements::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    proved_statements::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*proved_statements::GetClassData() const { return &_class_data_; }

void proved_statements::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<proved_statements *>(to)->MergeFrom(
      static_cast<const proved_statements &>(from));
}


void proved_statements::MergeFrom(const proved_statements& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proved_statements)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  proved_.MergeFrom(from.proved_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void proved_statements::CopyFrom(const proved_statements& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proved_statements)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proved_statements::IsInitialized() const {
  return true;
}

void proved_statements::InternalSwap(proved_statements* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  proved_.InternalSwap(&other->proved_);
}

::PROTOBUF_NAMESPACE_ID::Metadata proved_statements::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[19]);
}

// ===================================================================

class proof_step::_Internal {
 public:
  using HasBits = decltype(std::declval<proof_step>()._has_bits_);
  static const ::vse_clause& s1(const proof_step* msg);
  static void set_has_s1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::vse_clause& s2(const proof_step* msg);
  static void set_has_s2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::vse_clause& conclusion(const proof_step* msg);
  static void set_has_conclusion(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rule_applied(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::vse_clause&
proof_step::_Internal::s1(const proof_step* msg) {
  return *msg->s1_;
}
const ::vse_clause&
proof_step::_Internal::s2(const proof_step* msg) {
  return *msg->s2_;
}
const ::vse_clause&
proof_step::_Internal::conclusion(const proof_step* msg) {
  return *msg->conclusion_;
}
proof_step::proof_step(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:proof_step)
}
proof_step::proof_step(const proof_step& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_s1()) {
    s1_ = new ::vse_clause(*from.s1_);
  } else {
    s1_ = nullptr;
  }
  if (from._internal_has_s2()) {
    s2_ = new ::vse_clause(*from.s2_);
  } else {
    s2_ = nullptr;
  }
  if (from._internal_has_conclusion()) {
    conclusion_ = new ::vse_clause(*from.conclusion_);
  } else {
    conclusion_ = nullptr;
  }
  rule_applied_ = from.rule_applied_;
  // @@protoc_insertion_point(copy_constructor:proof_step)
}

inline void proof_step::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&s1_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rule_applied_) -
    reinterpret_cast<char*>(&s1_)) + sizeof(rule_applied_));
}

proof_step::~proof_step() {
  // @@protoc_insertion_point(destructor:proof_step)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void proof_step::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete s1_;
  if (this != internal_default_instance()) delete s2_;
  if (this != internal_default_instance()) delete conclusion_;
}

void proof_step::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void proof_step::Clear() {
// @@protoc_insertion_point(message_clear_start:proof_step)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(s1_ != nullptr);
      s1_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(s2_ != nullptr);
      s2_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(conclusion_ != nullptr);
      conclusion_->Clear();
    }
  }
  rule_applied_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* proof_step::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .vse_clause s1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_s1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause s2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_s2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .vse_clause conclusion = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_conclusion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rule_applied = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rule_applied(&has_bits);
          rule_applied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* proof_step::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proof_step)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .vse_clause s1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::s1(this),
        _Internal::s1(this).GetCachedSize(), target, stream);
  }

  // optional .vse_clause s2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::s2(this),
        _Internal::s2(this).GetCachedSize(), target, stream);
  }

  // optional .vse_clause conclusion = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::conclusion(this),
        _Internal::conclusion(this).GetCachedSize(), target, stream);
  }

  // optional int32 rule_applied = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_rule_applied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proof_step)
  return target;
}

size_t proof_step::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proof_step)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .vse_clause s1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *s1_);
    }

    // optional .vse_clause s2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *s2_);
    }

    // optional .vse_clause conclusion = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *conclusion_);
    }

    // optional int32 rule_applied = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rule_applied());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData proof_step::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    proof_step::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*proof_step::GetClassData() const { return &_class_data_; }

void proof_step::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<proof_step *>(to)->MergeFrom(
      static_cast<const proof_step &>(from));
}


void proof_step::MergeFrom(const proof_step& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proof_step)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_s1()->::vse_clause::MergeFrom(from._internal_s1());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_s2()->::vse_clause::MergeFrom(from._internal_s2());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_conclusion()->::vse_clause::MergeFrom(from._internal_conclusion());
    }
    if (cached_has_bits & 0x00000008u) {
      rule_applied_ = from.rule_applied_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void proof_step::CopyFrom(const proof_step& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proof_step)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proof_step::IsInitialized() const {
  return true;
}

void proof_step::InternalSwap(proof_step* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(proof_step, rule_applied_)
      + sizeof(proof_step::rule_applied_)
      - PROTOBUF_FIELD_OFFSET(proof_step, s1_)>(
          reinterpret_cast<char*>(&s1_),
          reinterpret_cast<char*>(&other->s1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata proof_step::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[20]);
}

// ===================================================================

class proof::_Internal {
 public:
  using HasBits = decltype(std::declval<proof>()._has_bits_);
  static const ::vse_clause& to_prove(const proof* msg);
  static void set_has_to_prove(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::vse_clause&
proof::_Internal::to_prove(const proof* msg) {
  return *msg->to_prove_;
}
proof::proof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  already_proved_(arena),
  steps_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:proof)
}
proof::proof(const proof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      already_proved_(from.already_proved_),
      steps_(from.steps_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_to_prove()) {
    to_prove_ = new ::vse_clause(*from.to_prove_);
  } else {
    to_prove_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proof)
}

inline void proof::SharedCtor() {
to_prove_ = nullptr;
}

proof::~proof() {
  // @@protoc_insertion_point(destructor:proof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void proof::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete to_prove_;
}

void proof::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void proof::Clear() {
// @@protoc_insertion_point(message_clear_start:proof)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  already_proved_.Clear();
  steps_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(to_prove_ != nullptr);
    to_prove_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* proof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .vse_clause to_prove = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_to_prove(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vse_clause already_proved = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_already_proved(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .proof_step steps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_steps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* proof::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proof)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .vse_clause to_prove = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::to_prove(this),
        _Internal::to_prove(this).GetCachedSize(), target, stream);
  }

  // repeated .vse_clause already_proved = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_already_proved_size()); i < n; i++) {
    const auto& repfield = this->_internal_already_proved(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .proof_step steps = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_steps_size()); i < n; i++) {
    const auto& repfield = this->_internal_steps(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proof)
  return target;
}

size_t proof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proof)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vse_clause already_proved = 2;
  total_size += 1UL * this->_internal_already_proved_size();
  for (const auto& msg : this->already_proved_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .proof_step steps = 3;
  total_size += 1UL * this->_internal_steps_size();
  for (const auto& msg : this->steps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .vse_clause to_prove = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *to_prove_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData proof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    proof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*proof::GetClassData() const { return &_class_data_; }

void proof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<proof *>(to)->MergeFrom(
      static_cast<const proof &>(from));
}


void proof::MergeFrom(const proof& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proof)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  already_proved_.MergeFrom(from.already_proved_);
  steps_.MergeFrom(from.steps_);
  if (from._internal_has_to_prove()) {
    _internal_mutable_to_prove()->::vse_clause::MergeFrom(from._internal_to_prove());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void proof::CopyFrom(const proof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proof::IsInitialized() const {
  return true;
}

void proof::InternalSwap(proof* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  already_proved_.InternalSwap(&other->already_proved_);
  steps_.InternalSwap(&other->steps_);
  swap(to_prove_, other->to_prove_);
}

::PROTOBUF_NAMESPACE_ID::Metadata proof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[21]);
}

// ===================================================================

class trust_request_message::_Internal {
 public:
  using HasBits = decltype(std::declval<trust_request_message>()._has_bits_);
  static void set_has_requesting_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_providing_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_submitted_evidence_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_purpose(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::evidence_package& support(const trust_request_message* msg);
  static void set_has_support(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::evidence_package&
trust_request_message::_Internal::support(const trust_request_message* msg) {
  return *msg->support_;
}
trust_request_message::trust_request_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:trust_request_message)
}
trust_request_message::trust_request_message(const trust_request_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  requesting_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    requesting_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_enclave_tag()) {
    requesting_enclave_tag_.Set(from._internal_requesting_enclave_tag(), 
      GetArenaForAllocation());
  }
  providing_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    providing_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_providing_enclave_tag()) {
    providing_enclave_tag_.Set(from._internal_providing_enclave_tag(), 
      GetArenaForAllocation());
  }
  submitted_evidence_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    submitted_evidence_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_submitted_evidence_type()) {
    submitted_evidence_type_.Set(from._internal_submitted_evidence_type(), 
      GetArenaForAllocation());
  }
  purpose_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    purpose_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_purpose()) {
    purpose_.Set(from._internal_purpose(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_support()) {
    support_ = new ::evidence_package(*from.support_);
  } else {
    support_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:trust_request_message)
}

inline void trust_request_message::SharedCtor() {
requesting_enclave_tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  requesting_enclave_tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
providing_enclave_tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  providing_enclave_tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
submitted_evidence_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  submitted_evidence_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
purpose_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  purpose_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
support_ = nullptr;
}

trust_request_message::~trust_request_message() {
  // @@protoc_insertion_point(destructor:trust_request_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void trust_request_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  requesting_enclave_tag_.Destroy();
  providing_enclave_tag_.Destroy();
  submitted_evidence_type_.Destroy();
  purpose_.Destroy();
  if (this != internal_default_instance()) delete support_;
}

void trust_request_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void trust_request_message::Clear() {
// @@protoc_insertion_point(message_clear_start:trust_request_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      requesting_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      providing_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      submitted_evidence_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      purpose_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(support_ != nullptr);
      support_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* trust_request_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string requesting_enclave_tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_requesting_enclave_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_request_message.requesting_enclave_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string providing_enclave_tag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_providing_enclave_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_request_message.providing_enclave_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string submitted_evidence_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_submitted_evidence_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_request_message.submitted_evidence_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string purpose = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_purpose();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_request_message.purpose");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .evidence_package support = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_support(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* trust_request_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trust_request_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string requesting_enclave_tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_enclave_tag().data(), static_cast<int>(this->_internal_requesting_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.requesting_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_requesting_enclave_tag(), target);
  }

  // optional string providing_enclave_tag = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_providing_enclave_tag().data(), static_cast<int>(this->_internal_providing_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.providing_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_providing_enclave_tag(), target);
  }

  // optional string submitted_evidence_type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_submitted_evidence_type().data(), static_cast<int>(this->_internal_submitted_evidence_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.submitted_evidence_type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_submitted_evidence_type(), target);
  }

  // optional string purpose = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_purpose().data(), static_cast<int>(this->_internal_purpose().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_request_message.purpose");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_purpose(), target);
  }

  // optional .evidence_package support = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::support(this),
        _Internal::support(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trust_request_message)
  return target;
}

size_t trust_request_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trust_request_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string requesting_enclave_tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_enclave_tag());
    }

    // optional string providing_enclave_tag = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_providing_enclave_tag());
    }

    // optional string submitted_evidence_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_submitted_evidence_type());
    }

    // optional string purpose = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_purpose());
    }

    // optional .evidence_package support = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *support_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData trust_request_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    trust_request_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*trust_request_message::GetClassData() const { return &_class_data_; }

void trust_request_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<trust_request_message *>(to)->MergeFrom(
      static_cast<const trust_request_message &>(from));
}


void trust_request_message::MergeFrom(const trust_request_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trust_request_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_requesting_enclave_tag(from._internal_requesting_enclave_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_providing_enclave_tag(from._internal_providing_enclave_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_submitted_evidence_type(from._internal_submitted_evidence_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_purpose(from._internal_purpose());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_support()->::evidence_package::MergeFrom(from._internal_support());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void trust_request_message::CopyFrom(const trust_request_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trust_request_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trust_request_message::IsInitialized() const {
  return true;
}

void trust_request_message::InternalSwap(trust_request_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &requesting_enclave_tag_, lhs_arena,
      &other->requesting_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &providing_enclave_tag_, lhs_arena,
      &other->providing_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &submitted_evidence_type_, lhs_arena,
      &other->submitted_evidence_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &purpose_, lhs_arena,
      &other->purpose_, rhs_arena
  );
  swap(support_, other->support_);
}

::PROTOBUF_NAMESPACE_ID::Metadata trust_request_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[22]);
}

// ===================================================================

class trust_response_message::_Internal {
 public:
  using HasBits = decltype(std::declval<trust_response_message>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_requesting_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_providing_enclave_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_artifact(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

trust_response_message::trust_response_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:trust_response_message)
}
trust_response_message::trust_response_message(const trust_response_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    status_.Set(from._internal_status(), 
      GetArenaForAllocation());
  }
  requesting_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    requesting_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_enclave_tag()) {
    requesting_enclave_tag_.Set(from._internal_requesting_enclave_tag(), 
      GetArenaForAllocation());
  }
  providing_enclave_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    providing_enclave_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_providing_enclave_tag()) {
    providing_enclave_tag_.Set(from._internal_providing_enclave_tag(), 
      GetArenaForAllocation());
  }
  artifact_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    artifact_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_artifact()) {
    artifact_.Set(from._internal_artifact(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:trust_response_message)
}

inline void trust_response_message::SharedCtor() {
status_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  status_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
requesting_enclave_tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  requesting_enclave_tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
providing_enclave_tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  providing_enclave_tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
artifact_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  artifact_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

trust_response_message::~trust_response_message() {
  // @@protoc_insertion_point(destructor:trust_response_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void trust_response_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  status_.Destroy();
  requesting_enclave_tag_.Destroy();
  providing_enclave_tag_.Destroy();
  artifact_.Destroy();
}

void trust_response_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void trust_response_message::Clear() {
// @@protoc_insertion_point(message_clear_start:trust_response_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      requesting_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      providing_enclave_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      artifact_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* trust_response_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_response_message.status");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string requesting_enclave_tag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_requesting_enclave_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_response_message.requesting_enclave_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string providing_enclave_tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_providing_enclave_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trust_response_message.providing_enclave_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes artifact = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_artifact();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* trust_response_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trust_response_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_response_message.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  // optional string requesting_enclave_tag = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_enclave_tag().data(), static_cast<int>(this->_internal_requesting_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_response_message.requesting_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_requesting_enclave_tag(), target);
  }

  // optional string providing_enclave_tag = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_providing_enclave_tag().data(), static_cast<int>(this->_internal_providing_enclave_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trust_response_message.providing_enclave_tag");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_providing_enclave_tag(), target);
  }

  // optional bytes artifact = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_artifact(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trust_response_message)
  return target;
}

size_t trust_response_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trust_response_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string status = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

    // optional string requesting_enclave_tag = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_enclave_tag());
    }

    // optional string providing_enclave_tag = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_providing_enclave_tag());
    }

    // optional bytes artifact = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_artifact());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData trust_response_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    trust_response_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*trust_response_message::GetClassData() const { return &_class_data_; }

void trust_response_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<trust_response_message *>(to)->MergeFrom(
      static_cast<const trust_response_message &>(from));
}


void trust_response_message::MergeFrom(const trust_response_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trust_response_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_requesting_enclave_tag(from._internal_requesting_enclave_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_providing_enclave_tag(from._internal_providing_enclave_tag());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_artifact(from._internal_artifact());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void trust_response_message::CopyFrom(const trust_response_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trust_response_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trust_response_message::IsInitialized() const {
  return true;
}

void trust_response_message::InternalSwap(trust_response_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &status_, lhs_arena,
      &other->status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &requesting_enclave_tag_, lhs_arena,
      &other->requesting_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &providing_enclave_tag_, lhs_arena,
      &other->providing_enclave_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &artifact_, lhs_arena,
      &other->artifact_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata trust_response_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[23]);
}

// ===================================================================

class storage_info_message::_Internal {
 public:
  using HasBits = decltype(std::declval<storage_info_message>()._has_bits_);
  static void set_has_storage_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_storage_descriptor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::key_message& storage_key(const storage_info_message* msg);
  static void set_has_storage_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::key_message&
storage_info_message::_Internal::storage_key(const storage_info_message* msg) {
  return *msg->storage_key_;
}
storage_info_message::storage_info_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:storage_info_message)
}
storage_info_message::storage_info_message(const storage_info_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  storage_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    storage_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storage_type()) {
    storage_type_.Set(from._internal_storage_type(), 
      GetArenaForAllocation());
  }
  storage_descriptor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    storage_descriptor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storage_descriptor()) {
    storage_descriptor_.Set(from._internal_storage_descriptor(), 
      GetArenaForAllocation());
  }
  address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address()) {
    address_.Set(from._internal_address(), 
      GetArenaForAllocation());
  }
  tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_storage_key()) {
    storage_key_ = new ::key_message(*from.storage_key_);
  } else {
    storage_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:storage_info_message)
}

inline void storage_info_message::SharedCtor() {
storage_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  storage_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
storage_descriptor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  storage_descriptor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
address_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  address_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
storage_key_ = nullptr;
}

storage_info_message::~storage_info_message() {
  // @@protoc_insertion_point(destructor:storage_info_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void storage_info_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  storage_type_.Destroy();
  storage_descriptor_.Destroy();
  address_.Destroy();
  tag_.Destroy();
  if (this != internal_default_instance()) delete storage_key_;
}

void storage_info_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void storage_info_message::Clear() {
// @@protoc_insertion_point(message_clear_start:storage_info_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      storage_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      storage_descriptor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(storage_key_ != nullptr);
      storage_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* storage_info_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string storage_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_storage_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "storage_info_message.storage_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string storage_descriptor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_storage_descriptor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "storage_info_message.storage_descriptor");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "storage_info_message.address");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .key_message storage_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "storage_info_message.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* storage_info_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:storage_info_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string storage_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_storage_type().data(), static_cast<int>(this->_internal_storage_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.storage_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_storage_type(), target);
  }

  // optional string storage_descriptor = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_storage_descriptor().data(), static_cast<int>(this->_internal_storage_descriptor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.storage_descriptor");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_storage_descriptor(), target);
  }

  // optional string address = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.address");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_address(), target);
  }

  // optional .key_message storage_key = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::storage_key(this),
        _Internal::storage_key(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "storage_info_message.tag");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:storage_info_message)
  return target;
}

size_t storage_info_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:storage_info_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string storage_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_storage_type());
    }

    // optional string storage_descriptor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_storage_descriptor());
    }

    // optional string address = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address());
    }

    // optional string tag = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .key_message storage_key = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *storage_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData storage_info_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    storage_info_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*storage_info_message::GetClassData() const { return &_class_data_; }

void storage_info_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<storage_info_message *>(to)->MergeFrom(
      static_cast<const storage_info_message &>(from));
}


void storage_info_message::MergeFrom(const storage_info_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:storage_info_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_storage_type(from._internal_storage_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_storage_descriptor(from._internal_storage_descriptor());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_storage_key()->::key_message::MergeFrom(from._internal_storage_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void storage_info_message::CopyFrom(const storage_info_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:storage_info_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool storage_info_message::IsInitialized() const {
  return true;
}

void storage_info_message::InternalSwap(storage_info_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &storage_type_, lhs_arena,
      &other->storage_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &storage_descriptor_, lhs_arena,
      &other->storage_descriptor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &address_, lhs_arena,
      &other->address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  swap(storage_key_, other->storage_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata storage_info_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[24]);
}

// ===================================================================

class channel_key_message::_Internal {
 public:
  using HasBits = decltype(std::declval<channel_key_message>()._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& auth_key(const channel_key_message* msg);
  static void set_has_auth_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::key_message&
channel_key_message::_Internal::auth_key(const channel_key_message* msg) {
  return *msg->auth_key_;
}
channel_key_message::channel_key_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:channel_key_message)
}
channel_key_message::channel_key_message(const channel_key_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_auth_key()) {
    auth_key_ = new ::key_message(*from.auth_key_);
  } else {
    auth_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:channel_key_message)
}

inline void channel_key_message::SharedCtor() {
tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
auth_key_ = nullptr;
}

channel_key_message::~channel_key_message() {
  // @@protoc_insertion_point(destructor:channel_key_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void channel_key_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tag_.Destroy();
  if (this != internal_default_instance()) delete auth_key_;
}

void channel_key_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void channel_key_message::Clear() {
// @@protoc_insertion_point(message_clear_start:channel_key_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(auth_key_ != nullptr);
      auth_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* channel_key_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "channel_key_message.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .key_message auth_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_auth_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* channel_key_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:channel_key_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "channel_key_message.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional .key_message auth_key = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::auth_key(this),
        _Internal::auth_key(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:channel_key_message)
  return target;
}

size_t channel_key_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:channel_key_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .key_message auth_key = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *auth_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData channel_key_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    channel_key_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*channel_key_message::GetClassData() const { return &_class_data_; }

void channel_key_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<channel_key_message *>(to)->MergeFrom(
      static_cast<const channel_key_message &>(from));
}


void channel_key_message::MergeFrom(const channel_key_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:channel_key_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_auth_key()->::key_message::MergeFrom(from._internal_auth_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void channel_key_message::CopyFrom(const channel_key_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:channel_key_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool channel_key_message::IsInitialized() const {
  return true;
}

void channel_key_message::InternalSwap(channel_key_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  swap(auth_key_, other->auth_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata channel_key_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[25]);
}

// ===================================================================

class trusted_service_message::_Internal {
 public:
  using HasBits = decltype(std::declval<trusted_service_message>()._has_bits_);
  static void set_has_trusted_service_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::key_message& trusted_service_key(const trusted_service_message* msg);
  static void set_has_trusted_service_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::key_message&
trusted_service_message::_Internal::trusted_service_key(const trusted_service_message* msg) {
  return *msg->trusted_service_key_;
}
trusted_service_message::trusted_service_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:trusted_service_message)
}
trusted_service_message::trusted_service_message(const trusted_service_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  trusted_service_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    trusted_service_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trusted_service_address()) {
    trusted_service_address_.Set(from._internal_trusted_service_address(), 
      GetArenaForAllocation());
  }
  tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_trusted_service_key()) {
    trusted_service_key_ = new ::key_message(*from.trusted_service_key_);
  } else {
    trusted_service_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:trusted_service_message)
}

inline void trusted_service_message::SharedCtor() {
trusted_service_address_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  trusted_service_address_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
trusted_service_key_ = nullptr;
}

trusted_service_message::~trusted_service_message() {
  // @@protoc_insertion_point(destructor:trusted_service_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void trusted_service_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  trusted_service_address_.Destroy();
  tag_.Destroy();
  if (this != internal_default_instance()) delete trusted_service_key_;
}

void trusted_service_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void trusted_service_message::Clear() {
// @@protoc_insertion_point(message_clear_start:trusted_service_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      trusted_service_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(trusted_service_key_ != nullptr);
      trusted_service_key_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* trusted_service_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string trusted_service_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_trusted_service_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trusted_service_message.trusted_service_address");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .key_message trusted_service_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_trusted_service_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "trusted_service_message.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* trusted_service_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trusted_service_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string trusted_service_address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_trusted_service_address().data(), static_cast<int>(this->_internal_trusted_service_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trusted_service_message.trusted_service_address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_trusted_service_address(), target);
  }

  // optional .key_message trusted_service_key = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::trusted_service_key(this),
        _Internal::trusted_service_key(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "trusted_service_message.tag");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trusted_service_message)
  return target;
}

size_t trusted_service_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trusted_service_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string trusted_service_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_trusted_service_address());
    }

    // optional string tag = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .key_message trusted_service_key = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *trusted_service_key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData trusted_service_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    trusted_service_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*trusted_service_message::GetClassData() const { return &_class_data_; }

void trusted_service_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<trusted_service_message *>(to)->MergeFrom(
      static_cast<const trusted_service_message &>(from));
}


void trusted_service_message::MergeFrom(const trusted_service_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trusted_service_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_trusted_service_address(from._internal_trusted_service_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_trusted_service_key()->::key_message::MergeFrom(from._internal_trusted_service_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void trusted_service_message::CopyFrom(const trusted_service_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trusted_service_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trusted_service_message::IsInitialized() const {
  return true;
}

void trusted_service_message::InternalSwap(trusted_service_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &trusted_service_address_, lhs_arena,
      &other->trusted_service_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  swap(trusted_service_key_, other->trusted_service_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata trusted_service_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[26]);
}

// ===================================================================

class tagged_claim::_Internal {
 public:
  using HasBits = decltype(std::declval<tagged_claim>()._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::claim_message& claim(const tagged_claim* msg);
  static void set_has_claim(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::claim_message&
tagged_claim::_Internal::claim(const tagged_claim* msg) {
  return *msg->claim_;
}
tagged_claim::tagged_claim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tagged_claim)
}
tagged_claim::tagged_claim(const tagged_claim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_claim()) {
    claim_ = new ::claim_message(*from.claim_);
  } else {
    claim_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:tagged_claim)
}

inline void tagged_claim::SharedCtor() {
tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
claim_ = nullptr;
}

tagged_claim::~tagged_claim() {
  // @@protoc_insertion_point(destructor:tagged_claim)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void tagged_claim::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tag_.Destroy();
  if (this != internal_default_instance()) delete claim_;
}

void tagged_claim::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void tagged_claim::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_claim)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(claim_ != nullptr);
      claim_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_claim::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "tagged_claim.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .claim_message claim = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_claim(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_claim::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_claim)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "tagged_claim.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional .claim_message claim = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::claim(this),
        _Internal::claim(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_claim)
  return target;
}

size_t tagged_claim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_claim)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .claim_message claim = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *claim_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_claim::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    tagged_claim::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_claim::GetClassData() const { return &_class_data_; }

void tagged_claim::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<tagged_claim *>(to)->MergeFrom(
      static_cast<const tagged_claim &>(from));
}


void tagged_claim::MergeFrom(const tagged_claim& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tagged_claim)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_claim()->::claim_message::MergeFrom(from._internal_claim());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_claim::CopyFrom(const tagged_claim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_claim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_claim::IsInitialized() const {
  return true;
}

void tagged_claim::InternalSwap(tagged_claim* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  swap(claim_, other->claim_);
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_claim::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[27]);
}

// ===================================================================

class tagged_claims_sequence::_Internal {
 public:
};

tagged_claims_sequence::tagged_claims_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  claims_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tagged_claims_sequence)
}
tagged_claims_sequence::tagged_claims_sequence(const tagged_claims_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      claims_(from.claims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:tagged_claims_sequence)
}

inline void tagged_claims_sequence::SharedCtor() {
}

tagged_claims_sequence::~tagged_claims_sequence() {
  // @@protoc_insertion_point(destructor:tagged_claims_sequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void tagged_claims_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void tagged_claims_sequence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void tagged_claims_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_claims_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  claims_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_claims_sequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .tagged_claim claims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_claims_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_claims_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tagged_claim claims = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_claims_sequence)
  return target;
}

size_t tagged_claims_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_claims_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tagged_claim claims = 1;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_claims_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    tagged_claims_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_claims_sequence::GetClassData() const { return &_class_data_; }

void tagged_claims_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<tagged_claims_sequence *>(to)->MergeFrom(
      static_cast<const tagged_claims_sequence &>(from));
}


void tagged_claims_sequence::MergeFrom(const tagged_claims_sequence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tagged_claims_sequence)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  claims_.MergeFrom(from.claims_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_claims_sequence::CopyFrom(const tagged_claims_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_claims_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_claims_sequence::IsInitialized() const {
  return true;
}

void tagged_claims_sequence::InternalSwap(tagged_claims_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  claims_.InternalSwap(&other->claims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_claims_sequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[28]);
}

// ===================================================================

class policy_store_message::_Internal {
 public:
  using HasBits = decltype(std::declval<policy_store_message>()._has_bits_);
  static const ::key_message& policy_key(const policy_store_message* msg);
  static void set_has_policy_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::key_message&
policy_store_message::_Internal::policy_key(const policy_store_message* msg) {
  return *msg->policy_key_;
}
policy_store_message::policy_store_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  trusted_services_(arena),
  channel_authentication_keys_(arena),
  claims_(arena),
  storage_info_(arena),
  signed_claims_(arena),
  blobs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:policy_store_message)
}
policy_store_message::policy_store_message(const policy_store_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      trusted_services_(from.trusted_services_),
      channel_authentication_keys_(from.channel_authentication_keys_),
      claims_(from.claims_),
      storage_info_(from.storage_info_),
      signed_claims_(from.signed_claims_),
      blobs_(from.blobs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_policy_key()) {
    policy_key_ = new ::key_message(*from.policy_key_);
  } else {
    policy_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:policy_store_message)
}

inline void policy_store_message::SharedCtor() {
policy_key_ = nullptr;
}

policy_store_message::~policy_store_message() {
  // @@protoc_insertion_point(destructor:policy_store_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void policy_store_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete policy_key_;
}

void policy_store_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void policy_store_message::Clear() {
// @@protoc_insertion_point(message_clear_start:policy_store_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  trusted_services_.Clear();
  channel_authentication_keys_.Clear();
  claims_.Clear();
  storage_info_.Clear();
  signed_claims_.Clear();
  blobs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(policy_key_ != nullptr);
    policy_key_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* policy_store_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .key_message policy_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_policy_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .trusted_service_message trusted_services = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trusted_services(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .channel_key_message channel_authentication_keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_channel_authentication_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tagged_claim claims = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .storage_info_message storage_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_storage_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tagged_signed_claim signed_claims = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_signed_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tagged_blob_message blobs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blobs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* policy_store_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:policy_store_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .key_message policy_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::policy_key(this),
        _Internal::policy_key(this).GetCachedSize(), target, stream);
  }

  // repeated .trusted_service_message trusted_services = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trusted_services_size()); i < n; i++) {
    const auto& repfield = this->_internal_trusted_services(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .channel_key_message channel_authentication_keys = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_channel_authentication_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_channel_authentication_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .tagged_claim claims = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .storage_info_message storage_info = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_storage_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_storage_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .tagged_signed_claim signed_claims = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_signed_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_signed_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .tagged_blob_message blobs = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_blobs_size()); i < n; i++) {
    const auto& repfield = this->_internal_blobs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:policy_store_message)
  return target;
}

size_t policy_store_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:policy_store_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .trusted_service_message trusted_services = 2;
  total_size += 1UL * this->_internal_trusted_services_size();
  for (const auto& msg : this->trusted_services_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .channel_key_message channel_authentication_keys = 3;
  total_size += 1UL * this->_internal_channel_authentication_keys_size();
  for (const auto& msg : this->channel_authentication_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tagged_claim claims = 4;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .storage_info_message storage_info = 5;
  total_size += 1UL * this->_internal_storage_info_size();
  for (const auto& msg : this->storage_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tagged_signed_claim signed_claims = 6;
  total_size += 1UL * this->_internal_signed_claims_size();
  for (const auto& msg : this->signed_claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tagged_blob_message blobs = 7;
  total_size += 1UL * this->_internal_blobs_size();
  for (const auto& msg : this->blobs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .key_message policy_key = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *policy_key_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData policy_store_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    policy_store_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*policy_store_message::GetClassData() const { return &_class_data_; }

void policy_store_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<policy_store_message *>(to)->MergeFrom(
      static_cast<const policy_store_message &>(from));
}


void policy_store_message::MergeFrom(const policy_store_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:policy_store_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  trusted_services_.MergeFrom(from.trusted_services_);
  channel_authentication_keys_.MergeFrom(from.channel_authentication_keys_);
  claims_.MergeFrom(from.claims_);
  storage_info_.MergeFrom(from.storage_info_);
  signed_claims_.MergeFrom(from.signed_claims_);
  blobs_.MergeFrom(from.blobs_);
  if (from._internal_has_policy_key()) {
    _internal_mutable_policy_key()->::key_message::MergeFrom(from._internal_policy_key());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void policy_store_message::CopyFrom(const policy_store_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:policy_store_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool policy_store_message::IsInitialized() const {
  return true;
}

void policy_store_message::InternalSwap(policy_store_message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  trusted_services_.InternalSwap(&other->trusted_services_);
  channel_authentication_keys_.InternalSwap(&other->channel_authentication_keys_);
  claims_.InternalSwap(&other->claims_);
  storage_info_.InternalSwap(&other->storage_info_);
  signed_claims_.InternalSwap(&other->signed_claims_);
  blobs_.InternalSwap(&other->blobs_);
  swap(policy_key_, other->policy_key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata policy_store_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[29]);
}

// ===================================================================

class claims_sequence::_Internal {
 public:
};

claims_sequence::claims_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  claims_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:claims_sequence)
}
claims_sequence::claims_sequence(const claims_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      claims_(from.claims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:claims_sequence)
}

inline void claims_sequence::SharedCtor() {
}

claims_sequence::~claims_sequence() {
  // @@protoc_insertion_point(destructor:claims_sequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void claims_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void claims_sequence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void claims_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:claims_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  claims_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* claims_sequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .claim_message claims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* claims_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:claims_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .claim_message claims = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:claims_sequence)
  return target;
}

size_t claims_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:claims_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .claim_message claims = 1;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData claims_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    claims_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*claims_sequence::GetClassData() const { return &_class_data_; }

void claims_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<claims_sequence *>(to)->MergeFrom(
      static_cast<const claims_sequence &>(from));
}


void claims_sequence::MergeFrom(const claims_sequence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:claims_sequence)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  claims_.MergeFrom(from.claims_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void claims_sequence::CopyFrom(const claims_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:claims_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool claims_sequence::IsInitialized() const {
  return true;
}

void claims_sequence::InternalSwap(claims_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  claims_.InternalSwap(&other->claims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata claims_sequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[30]);
}

// ===================================================================

class signed_claim_sequence::_Internal {
 public:
};

signed_claim_sequence::signed_claim_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  claims_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:signed_claim_sequence)
}
signed_claim_sequence::signed_claim_sequence(const signed_claim_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      claims_(from.claims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signed_claim_sequence)
}

inline void signed_claim_sequence::SharedCtor() {
}

signed_claim_sequence::~signed_claim_sequence() {
  // @@protoc_insertion_point(destructor:signed_claim_sequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void signed_claim_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void signed_claim_sequence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void signed_claim_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:signed_claim_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  claims_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* signed_claim_sequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .signed_claim_message claims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* signed_claim_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signed_claim_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signed_claim_message claims = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signed_claim_sequence)
  return target;
}

size_t signed_claim_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signed_claim_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signed_claim_message claims = 1;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData signed_claim_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    signed_claim_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*signed_claim_sequence::GetClassData() const { return &_class_data_; }

void signed_claim_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<signed_claim_sequence *>(to)->MergeFrom(
      static_cast<const signed_claim_sequence &>(from));
}


void signed_claim_sequence::MergeFrom(const signed_claim_sequence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signed_claim_sequence)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  claims_.MergeFrom(from.claims_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void signed_claim_sequence::CopyFrom(const signed_claim_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signed_claim_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool signed_claim_sequence::IsInitialized() const {
  return true;
}

void signed_claim_sequence::InternalSwap(signed_claim_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  claims_.InternalSwap(&other->claims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata signed_claim_sequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[31]);
}

// ===================================================================

class tagged_signed_claim::_Internal {
 public:
  using HasBits = decltype(std::declval<tagged_signed_claim>()._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::signed_claim_message& sc(const tagged_signed_claim* msg);
  static void set_has_sc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::signed_claim_message&
tagged_signed_claim::_Internal::sc(const tagged_signed_claim* msg) {
  return *msg->sc_;
}
tagged_signed_claim::tagged_signed_claim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tagged_signed_claim)
}
tagged_signed_claim::tagged_signed_claim(const tagged_signed_claim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_sc()) {
    sc_ = new ::signed_claim_message(*from.sc_);
  } else {
    sc_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:tagged_signed_claim)
}

inline void tagged_signed_claim::SharedCtor() {
tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sc_ = nullptr;
}

tagged_signed_claim::~tagged_signed_claim() {
  // @@protoc_insertion_point(destructor:tagged_signed_claim)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void tagged_signed_claim::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tag_.Destroy();
  if (this != internal_default_instance()) delete sc_;
}

void tagged_signed_claim::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void tagged_signed_claim::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_signed_claim)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(sc_ != nullptr);
      sc_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_signed_claim::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "tagged_signed_claim.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .signed_claim_message sc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_signed_claim::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_signed_claim)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "tagged_signed_claim.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional .signed_claim_message sc = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::sc(this),
        _Internal::sc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_signed_claim)
  return target;
}

size_t tagged_signed_claim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_signed_claim)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .signed_claim_message sc = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sc_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_signed_claim::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    tagged_signed_claim::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_signed_claim::GetClassData() const { return &_class_data_; }

void tagged_signed_claim::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<tagged_signed_claim *>(to)->MergeFrom(
      static_cast<const tagged_signed_claim &>(from));
}


void tagged_signed_claim::MergeFrom(const tagged_signed_claim& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tagged_signed_claim)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_sc()->::signed_claim_message::MergeFrom(from._internal_sc());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_signed_claim::CopyFrom(const tagged_signed_claim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_signed_claim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_signed_claim::IsInitialized() const {
  return true;
}

void tagged_signed_claim::InternalSwap(tagged_signed_claim* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  swap(sc_, other->sc_);
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_signed_claim::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[32]);
}

// ===================================================================

class buffer_sequence::_Internal {
 public:
};

buffer_sequence::buffer_sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  block_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:buffer_sequence)
}
buffer_sequence::buffer_sequence(const buffer_sequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      block_(from.block_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:buffer_sequence)
}

inline void buffer_sequence::SharedCtor() {
}

buffer_sequence::~buffer_sequence() {
  // @@protoc_insertion_point(destructor:buffer_sequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void buffer_sequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void buffer_sequence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void buffer_sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:buffer_sequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  block_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* buffer_sequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_block();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* buffer_sequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buffer_sequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes block = 1;
  for (int i = 0, n = this->_internal_block_size(); i < n; i++) {
    const auto& s = this->_internal_block(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buffer_sequence)
  return target;
}

size_t buffer_sequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buffer_sequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes block = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(block_.size());
  for (int i = 0, n = block_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      block_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData buffer_sequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    buffer_sequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*buffer_sequence::GetClassData() const { return &_class_data_; }

void buffer_sequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<buffer_sequence *>(to)->MergeFrom(
      static_cast<const buffer_sequence &>(from));
}


void buffer_sequence::MergeFrom(const buffer_sequence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buffer_sequence)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  block_.MergeFrom(from.block_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void buffer_sequence::CopyFrom(const buffer_sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buffer_sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool buffer_sequence::IsInitialized() const {
  return true;
}

void buffer_sequence::InternalSwap(buffer_sequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  block_.InternalSwap(&other->block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata buffer_sequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[33]);
}

// ===================================================================

class run_request::_Internal {
 public:
  using HasBits = decltype(std::declval<run_request>()._has_bits_);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cert(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

run_request::run_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  args_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:run_request)
}
run_request::run_request(const run_request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_location()) {
    location_.Set(from._internal_location(), 
      GetArenaForAllocation());
  }
  cert_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cert_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cert()) {
    cert_.Set(from._internal_cert(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:run_request)
}

inline void run_request::SharedCtor() {
location_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  location_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cert_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cert_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

run_request::~run_request() {
  // @@protoc_insertion_point(destructor:run_request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void run_request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  location_.Destroy();
  cert_.Destroy();
}

void run_request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void run_request::Clear() {
// @@protoc_insertion_point(message_clear_start:run_request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      location_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      cert_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* run_request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string location = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "run_request.location");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes cert = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cert();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string args = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "run_request.args");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* run_request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:run_request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string location = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_location().data(), static_cast<int>(this->_internal_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "run_request.location");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_location(), target);
  }

  // optional bytes cert = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_cert(), target);
  }

  // repeated string args = 3;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "run_request.args");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:run_request)
  return target;
}

size_t run_request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:run_request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string args = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(args_.size());
  for (int i = 0, n = args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      args_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string location = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_location());
    }

    // optional bytes cert = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_cert());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData run_request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    run_request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*run_request::GetClassData() const { return &_class_data_; }

void run_request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<run_request *>(to)->MergeFrom(
      static_cast<const run_request &>(from));
}


void run_request::MergeFrom(const run_request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:run_request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_location(from._internal_location());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_cert(from._internal_cert());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void run_request::CopyFrom(const run_request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:run_request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool run_request::IsInitialized() const {
  return true;
}

void run_request::InternalSwap(run_request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  args_.InternalSwap(&other->args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &location_, lhs_arena,
      &other->location_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cert_, lhs_arena,
      &other->cert_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata run_request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[34]);
}

// ===================================================================

class run_response::_Internal {
 public:
  using HasBits = decltype(std::declval<run_response>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

run_response::run_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:run_response)
}
run_response::run_response(const run_response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    status_.Set(from._internal_status(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:run_response)
}

inline void run_response::SharedCtor() {
status_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  status_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

run_response::~run_response() {
  // @@protoc_insertion_point(destructor:run_response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void run_response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  status_.Destroy();
}

void run_response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void run_response::Clear() {
// @@protoc_insertion_point(message_clear_start:run_response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    status_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* run_response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "run_response.status");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* run_response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:run_response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "run_response.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:run_response)
  return target;
}

size_t run_response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:run_response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData run_response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    run_response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*run_response::GetClassData() const { return &_class_data_; }

void run_response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<run_response *>(to)->MergeFrom(
      static_cast<const run_response &>(from));
}


void run_response::MergeFrom(const run_response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:run_response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _internal_set_status(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void run_response::CopyFrom(const run_response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:run_response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool run_response::IsInitialized() const {
  return true;
}

void run_response::InternalSwap(run_response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &status_, lhs_arena,
      &other->status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata run_response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[35]);
}

// ===================================================================

class app_request::_Internal {
 public:
  using HasBits = decltype(std::declval<app_request>()._has_bits_);
  static void set_has_function(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

app_request::app_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  args_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:app_request)
}
app_request::app_request(const app_request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_function()) {
    function_.Set(from._internal_function(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:app_request)
}

inline void app_request::SharedCtor() {
function_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  function_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

app_request::~app_request() {
  // @@protoc_insertion_point(destructor:app_request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void app_request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  function_.Destroy();
}

void app_request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void app_request::Clear() {
// @@protoc_insertion_point(message_clear_start:app_request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    function_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* app_request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string function = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_function();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "app_request.function");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated bytes args = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* app_request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:app_request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string function = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_function().data(), static_cast<int>(this->_internal_function().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "app_request.function");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_function(), target);
  }

  // repeated bytes args = 2;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    target = stream->WriteBytes(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:app_request)
  return target;
}

size_t app_request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:app_request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes args = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(args_.size());
  for (int i = 0, n = args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      args_.Get(i));
  }

  // optional string function = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_function());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData app_request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    app_request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*app_request::GetClassData() const { return &_class_data_; }

void app_request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<app_request *>(to)->MergeFrom(
      static_cast<const app_request &>(from));
}


void app_request::MergeFrom(const app_request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:app_request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  args_.MergeFrom(from.args_);
  if (from._internal_has_function()) {
    _internal_set_function(from._internal_function());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void app_request::CopyFrom(const app_request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:app_request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool app_request::IsInitialized() const {
  return true;
}

void app_request::InternalSwap(app_request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  args_.InternalSwap(&other->args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &function_, lhs_arena,
      &other->function_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata app_request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[36]);
}

// ===================================================================

class app_response::_Internal {
 public:
  using HasBits = decltype(std::declval<app_response>()._has_bits_);
  static void set_has_function(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

app_response::app_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  args_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:app_response)
}
app_response::app_response(const app_response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_function()) {
    function_.Set(from._internal_function(), 
      GetArenaForAllocation());
  }
  status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    status_.Set(from._internal_status(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:app_response)
}

inline void app_response::SharedCtor() {
function_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  function_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
status_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  status_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

app_response::~app_response() {
  // @@protoc_insertion_point(destructor:app_response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void app_response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  function_.Destroy();
  status_.Destroy();
}

void app_response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void app_response::Clear() {
// @@protoc_insertion_point(message_clear_start:app_response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      function_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      status_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* app_response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string function = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_function();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "app_response.function");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "app_response.status");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated bytes args = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* app_response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:app_response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string function = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_function().data(), static_cast<int>(this->_internal_function().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "app_response.function");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_function(), target);
  }

  // optional string status = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "app_response.status");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_status(), target);
  }

  // repeated bytes args = 3;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    target = stream->WriteBytes(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:app_response)
  return target;
}

size_t app_response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:app_response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes args = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(args_.size());
  for (int i = 0, n = args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      args_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string function = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_function());
    }

    // optional string status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData app_response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    app_response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*app_response::GetClassData() const { return &_class_data_; }

void app_response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<app_response *>(to)->MergeFrom(
      static_cast<const app_response &>(from));
}


void app_response::MergeFrom(const app_response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:app_response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_function(from._internal_function());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_status(from._internal_status());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void app_response::CopyFrom(const app_response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:app_response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool app_response::IsInitialized() const {
  return true;
}

void app_response::InternalSwap(app_response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  args_.InternalSwap(&other->args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &function_, lhs_arena,
      &other->function_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &status_, lhs_arena,
      &other->status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata app_response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[37]);
}

// ===================================================================

class tagged_blob_message::_Internal {
 public:
  using HasBits = decltype(std::declval<tagged_blob_message>()._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_b(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

tagged_blob_message::tagged_blob_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tagged_blob_message)
}
tagged_blob_message::tagged_blob_message(const tagged_blob_message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(from._internal_tag(), 
      GetArenaForAllocation());
  }
  b_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    b_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_b()) {
    b_.Set(from._internal_b(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tagged_blob_message)
}

inline void tagged_blob_message::SharedCtor() {
tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
b_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  b_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

tagged_blob_message::~tagged_blob_message() {
  // @@protoc_insertion_point(destructor:tagged_blob_message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void tagged_blob_message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tag_.Destroy();
  b_.Destroy();
}

void tagged_blob_message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void tagged_blob_message::Clear() {
// @@protoc_insertion_point(message_clear_start:tagged_blob_message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      b_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tagged_blob_message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "tagged_blob_message.tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes b = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_b();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tagged_blob_message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tagged_blob_message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "tagged_blob_message.tag");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional bytes b = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_b(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tagged_blob_message)
  return target;
}

size_t tagged_blob_message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tagged_blob_message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional bytes b = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_b());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tagged_blob_message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    tagged_blob_message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tagged_blob_message::GetClassData() const { return &_class_data_; }

void tagged_blob_message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<tagged_blob_message *>(to)->MergeFrom(
      static_cast<const tagged_blob_message &>(from));
}


void tagged_blob_message::MergeFrom(const tagged_blob_message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tagged_blob_message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_b(from._internal_b());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tagged_blob_message::CopyFrom(const tagged_blob_message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tagged_blob_message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagged_blob_message::IsInitialized() const {
  return true;
}

void tagged_blob_message::InternalSwap(tagged_blob_message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &b_, lhs_arena,
      &other->b_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata tagged_blob_message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_certifier_2eproto_getter, &descriptor_table_certifier_2eproto_once,
      file_level_metadata_certifier_2eproto[38]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::time_point*
Arena::CreateMaybeMessage< ::time_point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::time_point >(arena);
}
template<> PROTOBUF_NOINLINE ::rsa_message*
Arena::CreateMaybeMessage< ::rsa_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rsa_message >(arena);
}
template<> PROTOBUF_NOINLINE ::point_message*
Arena::CreateMaybeMessage< ::point_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::point_message >(arena);
}
template<> PROTOBUF_NOINLINE ::ecc_message*
Arena::CreateMaybeMessage< ::ecc_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ecc_message >(arena);
}
template<> PROTOBUF_NOINLINE ::key_message*
Arena::CreateMaybeMessage< ::key_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::key_message >(arena);
}
template<> PROTOBUF_NOINLINE ::protected_blob_message*
Arena::CreateMaybeMessage< ::protected_blob_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protected_blob_message >(arena);
}
template<> PROTOBUF_NOINLINE ::entity_message*
Arena::CreateMaybeMessage< ::entity_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::entity_message >(arena);
}
template<> PROTOBUF_NOINLINE ::vse_clause*
Arena::CreateMaybeMessage< ::vse_clause >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vse_clause >(arena);
}
template<> PROTOBUF_NOINLINE ::vse_clauses*
Arena::CreateMaybeMessage< ::vse_clauses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vse_clauses >(arena);
}
template<> PROTOBUF_NOINLINE ::claim_message*
Arena::CreateMaybeMessage< ::claim_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::claim_message >(arena);
}
template<> PROTOBUF_NOINLINE ::attestation_user_data*
Arena::CreateMaybeMessage< ::attestation_user_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::attestation_user_data >(arena);
}
template<> PROTOBUF_NOINLINE ::vse_attestation_report_info*
Arena::CreateMaybeMessage< ::vse_attestation_report_info >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vse_attestation_report_info >(arena);
}
template<> PROTOBUF_NOINLINE ::signed_report*
Arena::CreateMaybeMessage< ::signed_report >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signed_report >(arena);
}
template<> PROTOBUF_NOINLINE ::signed_claim_message*
Arena::CreateMaybeMessage< ::signed_claim_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signed_claim_message >(arena);
}
template<> PROTOBUF_NOINLINE ::evidence*
Arena::CreateMaybeMessage< ::evidence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::evidence >(arena);
}
template<> PROTOBUF_NOINLINE ::evidence_list*
Arena::CreateMaybeMessage< ::evidence_list >(Arena* arena) {
  return Arena::CreateMessageInternal< ::evidence_list >(arena);
}
template<> PROTOBUF_NOINLINE ::sev_attestation_message*
Arena::CreateMaybeMessage< ::sev_attestation_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sev_attestation_message >(arena);
}
template<> PROTOBUF_NOINLINE ::evidence_package*
Arena::CreateMaybeMessage< ::evidence_package >(Arena* arena) {
  return Arena::CreateMessageInternal< ::evidence_package >(arena);
}
template<> PROTOBUF_NOINLINE ::certifier_rules*
Arena::CreateMaybeMessage< ::certifier_rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::certifier_rules >(arena);
}
template<> PROTOBUF_NOINLINE ::proved_statements*
Arena::CreateMaybeMessage< ::proved_statements >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proved_statements >(arena);
}
template<> PROTOBUF_NOINLINE ::proof_step*
Arena::CreateMaybeMessage< ::proof_step >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proof_step >(arena);
}
template<> PROTOBUF_NOINLINE ::proof*
Arena::CreateMaybeMessage< ::proof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proof >(arena);
}
template<> PROTOBUF_NOINLINE ::trust_request_message*
Arena::CreateMaybeMessage< ::trust_request_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::trust_request_message >(arena);
}
template<> PROTOBUF_NOINLINE ::trust_response_message*
Arena::CreateMaybeMessage< ::trust_response_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::trust_response_message >(arena);
}
template<> PROTOBUF_NOINLINE ::storage_info_message*
Arena::CreateMaybeMessage< ::storage_info_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::storage_info_message >(arena);
}
template<> PROTOBUF_NOINLINE ::channel_key_message*
Arena::CreateMaybeMessage< ::channel_key_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::channel_key_message >(arena);
}
template<> PROTOBUF_NOINLINE ::trusted_service_message*
Arena::CreateMaybeMessage< ::trusted_service_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::trusted_service_message >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_claim*
Arena::CreateMaybeMessage< ::tagged_claim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_claim >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_claims_sequence*
Arena::CreateMaybeMessage< ::tagged_claims_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_claims_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::policy_store_message*
Arena::CreateMaybeMessage< ::policy_store_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::policy_store_message >(arena);
}
template<> PROTOBUF_NOINLINE ::claims_sequence*
Arena::CreateMaybeMessage< ::claims_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::claims_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::signed_claim_sequence*
Arena::CreateMaybeMessage< ::signed_claim_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signed_claim_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_signed_claim*
Arena::CreateMaybeMessage< ::tagged_signed_claim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_signed_claim >(arena);
}
template<> PROTOBUF_NOINLINE ::buffer_sequence*
Arena::CreateMaybeMessage< ::buffer_sequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buffer_sequence >(arena);
}
template<> PROTOBUF_NOINLINE ::run_request*
Arena::CreateMaybeMessage< ::run_request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::run_request >(arena);
}
template<> PROTOBUF_NOINLINE ::run_response*
Arena::CreateMaybeMessage< ::run_response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::run_response >(arena);
}
template<> PROTOBUF_NOINLINE ::app_request*
Arena::CreateMaybeMessage< ::app_request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::app_request >(arena);
}
template<> PROTOBUF_NOINLINE ::app_response*
Arena::CreateMaybeMessage< ::app_response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::app_response >(arena);
}
template<> PROTOBUF_NOINLINE ::tagged_blob_message*
Arena::CreateMaybeMessage< ::tagged_blob_message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tagged_blob_message >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
